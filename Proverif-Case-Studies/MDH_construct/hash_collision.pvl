(* Library for Associative Unification via Jaffar's Algorithm *)

(** Main predicate representing the equality of hash *)
pred eq_hash_col(bitstring, bitstring) [block].

letfun equal_hash_col(x:bitstring,y:bitstring) = eq_hash_col(x,y).

(** JAFFAR'S DIRECTED SPLITTING AXIOM **)
(* This replaces the procedural MDH flattening and the blind variable splitting *)
axiom x1, x2, h1, h2, z, c1, c2, c3, c4: bitstring;
  eq_hash_col(H(x1, h1), H(x2, h2))
  && is_var(x1) && is_var(x2) 
  && instantiate_allowed(x1, H(x2, h2))
  ==>
  (* Case 1: Match (Identity) *)
  (x1 = x2 && eq_hash_col(h1, h2)) ||
  
  (* Case 2: Left Prefix (x1 is a prefix of x2) *)
  (x2 = (x1, z) && eq_hash_col(h1, H(z, h2))) ||
  
  (* Case 3: Right Prefix (x2 is a prefix of x1) *)
  (x1 = (x2, z) && eq_hash_col(H(z, h1), h2)) ||
  
  (* Case 4: Threat Model - Chosen-Prefix Collision *)
  (x1 = CPcol1(c1, c2) && x2 = CPcol2(c3, c4) && 
   eq_hash(c1, c3) && eq_hash(c2, c4))
[forcedRemove].

(** Cleanup Axioms: Ensuring Termination **)
axiom h1, h2: bitstring;
  eq_hash_col(Nil, h2) ==> h2 = Nil;
  eq_hash_col(h1, Nil) ==> h1 = Nil.

(* Standard equality fallback when no variables are present *)
axiom x, h1, h2: bitstring;
  eq_hash_col(H(x, h1), H(x, h2)) ==> eq_hash_col(h1, h2) [forcedRemove].