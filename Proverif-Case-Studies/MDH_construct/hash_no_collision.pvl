(* Library to encode the Merkle–Damgård hash using Jaffar's Algorithm *)

const Nil:bitstring.
fun H(bitstring,bitstring):bitstring.

(** Main predicate representing the equality of hash **)
(* This is now a 'blocked' predicate, meaning ProVerif will use 
   our axioms to solve it rather than internal syntactic equality *)
pred eq_hash(bitstring,bitstring) [block].

(* Standard constructor for hashes *)
letfun buildH(x:bitstring) = H(x,Nil).
letfun equal_hash(x:bitstring,y:bitstring) = eq_hash(x,y).

(** Helper functions for axioms **)

(* occurs(x,t) returns true when x occurs in t.*)
compfun occurs(any_type,any_type):bool =
  forall x:any_type; occurs(x,x) -> true
  otherwise forall x,t:any_type; occurs(x,t) if is_fun(t) -> occurs_args(x,t,0)
  otherwise forall x,t:any_type; occurs(x,t) -> false
.

compfun occurs_args(any_type,any_type,int):bool =
  forall x,t:any_type, n:int; occurs_args(x,t,n) if n >= arity(t) -> false
  otherwise forall x,t:any_type, n:int; occurs_args(x,t,n) if n < arity(t) ->
    if occurs(x,nth_arg(t,n)) then true else occurs_args(x,t,n+1)
.

compfun instantiate_allowed(bitstring,bitstring):bool =
  forall x1:bitstring; instantiate_allowed(x1,Nil) -> true
  otherwise forall x1,x2:bitstring; instantiate_allowed(x1,x2) if is_var(x2) -> false
  otherwise forall x1,x2,h2:bitstring; instantiate_allowed(x1,H(x2,h2)) -> not(is_var(x2)) && (occurs(x1,x2) || instantiate_allowed(x1,h2))
.

(** JAFFAR'S MINIMAL COMPLETE WORD UNIFICATION **)
(* This single axiom replaces the entire recursive MDH compfun *)
axiom x1,x2,h1,h2,z:bitstring;
  eq_hash(H(x1,h1),H(x2,h2)) 
  && is_var(x1) && is_var(x2)
  && instantiate_allowed(x1,H(x2,h2))
  ==>
  (* Case 1: The heads match exactly *)
  (x1 = x2 && eq_hash(h1, h2)) ||
  
  (* Case 2: x1 is a prefix of x2 (Directed Splitting) *)
  (x2 = (x1, z) && eq_hash(h1, H(z, h2))) ||
  
  (* Case 3: x2 is a prefix of x1 (Directed Splitting) *)
  (x1 = (x2, z) && eq_hash(H(z, h1), h2))
[forcedRemove].

(** Basic Termination Axioms **)
axiom h:bitstring;
  eq_hash(h,h) ==> true;
  eq_hash(Nil,h) ==> h = Nil;
  eq_hash(h,Nil) ==> h = Nil.

(* Syntactic simplification for identical prefixes *)
axiom x,h1,h2:bitstring;
  eq_hash(H(x,h1),H(x,h2)) ==> eq_hash(h1,h2) 
[forcedRemove,fullSat].