(* Sigma' case study: Jaffar A-Unification Implementation.
   This file utilizes Directed Splitting axioms to reason over 
   unbounded hash chains.
*)

channel c.

(** 1. Types **)
type G.
type t_exponent.
type t_sk.
type t_pk.
type t_key.
fun G2key(G): t_key [typeConverter].
fun G2bs(G): bitstring [typeConverter].
fun pk2bs(t_pk): bitstring [typeConverter].

(** 2. Diffie-Hellman Elements **)
const g: G.
fun exp(G, t_exponent): G.
equation forall y: t_exponent, z: t_exponent; exp(exp(g,y),z) = exp(exp(g,z),y).

(** 3. Signature & Message Extraction **)
fun sign(bitstring,t_sk):bitstring.
fun pk(t_sk):t_pk.

(* Extracts the hashed transcript from the signed packet [cite: 73] *)
fun getmsg(bitstring):bitstring
reduc forall m:bitstring, sk:t_sk; getmsg(sign(m,sk)) = m.

(* Cryptographic check of the signature key [cite: 89] *)
fun signCheck(bitstring, t_pk): bool
reduc forall m:bitstring, sk:t_sk; signCheck(sign(m,sk), pk(sk)) = true
      otherwise forall s:bitstring, pkS:t_pk; signCheck(s, pkS) = false.

(** 4. MAC Function **)
fun mac(bitstring, t_key):bitstring.

(** 5. Security Goals & Events [cite: 127] **)
event Dishonest(t_pk).
event acceptA(t_pk,t_pk,bitstring).
event sessionKeyA(t_pk,t_pk,t_key).
event initA(t_pk,t_pk,bitstring).
event acceptB(t_pk,t_pk,bitstring).
event sessionKeyB(t_pk,t_pk,t_key).
event initB(t_pk,t_pk,bitstring).

(* Authentication and Secrecy Queries [cite: 127] *)
query A:t_pk,B:t_pk,x:bitstring; event(acceptB(B,A,x)) ==> (event(initA(A,B,x)) || event(Dishonest(B)) || event(Dishonest(A))).
query A:t_pk,B:t_pk,x:bitstring; event(acceptA(A,B,x)) ==> (event(initB(B,A,x)) || event(Dishonest(A)) || event(Dishonest(B))).
query A:t_pk,B:t_pk,x:t_key; (event(sessionKeyA(B,A,x)) && attacker(x)) ==> (event(Dishonest(B)) || event(Dishonest(A))).

(** 6. Role Models & Protocol Logic **)
const initTag:bitstring.
const respTag:bitstring.
letfun init = initTag.
letfun resp = respTag.

def macro_SIGMA(eq_hash_pred, System) {

  let A(skA:t_sk, pkB:t_pk) =
     if pk(skA) <> pkB then 
     new x: t_exponent;
     new infoA:bitstring;
     let m1:bitstring = (exp(g,x),infoA) in
     out(c, m1);
     in(c, m2:bitstring) [precise];
     let (gy:G, infoB:bitstring) = m2 in
     if gy <> g  && not(isCol(G2bs(gy))) then
     event initA(pk(skA),pkB,(m1,m2));
     let k:t_key = G2key(exp(gy,x)) in
     
     (* Construct the transcript [cite: 81, 83] *)
     let transcript:bitstring = (exp(g,x),(infoA,(gy,infoB))) in
     (* Apply hash constructor [cite: 68] *)
     let ht:bitstring = buildH(transcript) in
     
     out(c, (sign( (ht,init), skA) , mac( pk2bs(pk(skA)), k ) ));
     in(c, (s:bitstring,m:bitstring));
     if signCheck(s, pkB) && m = mac( pk2bs(pkB), k ) then
     let (ht':bitstring, =resp) = getmsg(s) in
     
     (* The solver now uses Jaffar's Directed Splitting axioms 
        to unify ht and ht' [cite: 148, 150]
     *)
     if eq_hash_pred(ht,ht')
     then
        event acceptA(pk(skA),pkB,(m1,m2));
        event sessionKeyA(pk(skA),pkB,k).

  let B (skB:t_sk, pkA:t_pk) =
     if pk(skB) <> pkA then 
     in(c, m1:bitstring) [precise];
     let (gx:G, infoA:bitstring) = m1 in
     if gx <> g && not(isCol(G2bs(gx))) then
     new y: t_exponent;
     new infoB:bitstring;
     let m2:bitstring = ( exp(g,y), infoB ) in
     event initB(pk(skB),pkA, (m1,m2));
     out(c, m2);
     in(c, (s:bitstring,m:bitstring));
     let k:t_key = G2key(exp(gx,y)) in
     
     let transcript:bitstring = (gx,(infoA,(exp(g,y),infoB))) in
     let ht:bitstring = buildH(transcript) in
     
     if signCheck(s, pkA) && m = mac( pk2bs(pkA), k ) then
     let (ht':bitstring, =init) = getmsg(s) in
     
     (* Axiomatic check: Handles both standard equality and 
        Chosen-Prefix Collisions [cite: 186, 189] 
     *)
     if eq_hash_pred(ht',ht) then
     out(c, (sign( (ht,resp), skB), mac( pk2bs(pk(skB)), k ) ));
     event acceptB(pk(skB),pkA, (m1,m2));
     event sessionKeyB(pk(skB),pkA, k).

  table Keys(t_sk).

  let System =
     ! (new sk:t_sk; out(c, pk(sk)); insert Keys(sk))
     | ! (get Keys(skA:t_sk) in get Keys(skB:t_sk) in (A(skA, pk(skB)) | B(skB, pk(skA))))
     | ! (get Keys(skA:t_sk) in event Dishonest(pk(skA)); out(c,skA)).
}