 ---> Options chosen:
(* No flattening! *)
(* No collision! *)
(******* The number of arguments that is suitable for analyzing a protocol depends on the number of arguments given to MDH by honest agents.
Here it is 6. Collapse tuples of size allFlat <= size <= allFlat *)
fun MDH(bitstring):bitstring
reduc forall x:bitstring; MDH( NIL ) = NIL
(***** LIST FLATTENING *)
(* No flattening! *)
(***** HAPPY FLOW *)
(* For simplified IKE v2: 5 arguments (transcriptA): *)
otherwise forall x1:bitstring,x2:bitstring,x3:bitstring,x4:bitstring,x5:bitstring,x6:bitstring;
  MDH( (x1,x2,x3,x4,x5,x6) ) =
  H(x6,H(x5,H(x4,H(x3,H(x2,H(x1,NIL ))))))
(* and also 4 arguments (transcriptB): *)
otherwise forall x1:bitstring,x2:bitstring,x3:bitstring,x4:bitstring,x5:bitstring;
  MDH( (x1,x2,x3,x4,x5) ) =
  H(x5,H(x4,H(x3,H(x2,H(x1,NIL )))))
otherwise forall x:bitstring; MDH( x ) = NIL.
(******* The number of arguments that is suitable for analyzing a protocol depends on the number of arguments given to MDH by honest agents.
Here it is 6. Collapse tuples of size allFlat <= size <= allFlat *)
fun MDH_(bitstring):bitstring
reduc forall x:bitstring; MDH_( NIL ) = NIL
(***** LIST FLATTENING *)
(* No flattening! *)
(***** HAPPY FLOW *)
(* For simplified IKE v2: 5 arguments (transcriptA): *)
otherwise forall x1:bitstring,x2:bitstring,x3:bitstring,x4:bitstring,x5:bitstring,x6:bitstring;
  MDH_( (x1,x2,x3,x4,x5,x6) ) =
  H_(x6,H_(x5,H_(x4,H_(x3,H_(x2,H_(x1,NIL ))))))
(* and also 4 arguments (transcriptB): *)
otherwise forall x1:bitstring,x2:bitstring,x3:bitstring,x4:bitstring,x5:bitstring;
  MDH_( (x1,x2,x3,x4,x5) ) =
  H_(x5,H_(x4,H_(x3,H_(x2,H_(x1,NIL )))))
otherwise forall x:bitstring; MDH_( x ) = NIL.
\n ---> Running ProVerif, log file and html outputs in LOGs/__file:IKE_S_m4:noFlat+noCol_date:13.10.25-02h-13m-11s/LOG.txt. Only displaying errors and analysis results ...
START DATE: 13.10.25 -- 02:13:11
(* No flattening! *)
(* No collision! *)
File "simplified_ikeV2_HF_EC.pv.pv", line 135, character 8:
Warning: identifier H rebound.
File "simplified_ikeV2_HF_EC.pv.pv", line 184, character 8:
Warning: identifier H rebound.
Linear part:
exp_ideal(exp_ideal(g,y),z) = exp_ideal(exp_ideal(g,z),y)
Completing equations...
Completed equations:
exp_ideal(exp_ideal(g,y),z) = exp_ideal(exp_ideal(g,z),y)
Convergent part: No equation.
Completed destructors:
(fail-any || @mayfail_v) => fail-any
(v || @mayfail_v) => @mayfail_v if v ≠ true
(true || @mayfail_v) => true

signCheck(fail-any,@mayfail_v,@mayfail_v_1) => fail-any
signCheck(v,@mayfail_v,fail-any) => fail-any
signCheck(v,fail-any,v_1) => fail-any
signCheck(m,s,pkS) => false if (forall @gen, (s ≠ sign(m,@gen) | pkS ≠ pk(@gen)))
signCheck(m,sign(m,sk),pk(sk)) => true

sdec(v,fail-any) => fail-any
sdec(fail-any,@mayfail_v) => fail-any
sdec(v,v_1) => fail-any if (forall @gen, v ≠ senc(@gen,v_1))
sdec(senc(m,k),k) => m

not(fail-any) => fail-any
not(v) => true if v ≠ true
not(true) => false

is_nat(fail-any) => fail-any
is_nat(v) => false if is_not_nat(v)
is_nat(v) => true if is_nat(v)

isCol(fail-any) => fail-any
isCol(x) => false

exp(fail-any,@mayfail_v) => fail-any
exp(v,fail-any) => fail-any
exp(exp_ideal(g,y),z) => exp_ideal(exp_ideal(g,z),y) if z ≠ badElement
exp(a,y) => exp_ideal(a,y) if y ≠ badElement && a ≠ weak
exp(weak,y) => weak if y ≠ badElement
exp(a,badElement) => weak

MDH_(fail-any) => fail-any
MDH_(x) => NIL if x ≠ NIL && (forall @gen,@gen_1,@gen_2,@gen_3,@gen_4,@gen_5, x ≠ (@gen_5,@gen_4,@gen_3,@gen_2,@gen_1,@gen)) && (forall @gen_6,@gen_7,@gen_8,@gen_9,@gen_10, x ≠ (@gen_10,@gen_9,@gen_8,@gen_7,@gen_6))
MDH_((x1,x2,x3,x4,x5)) => H_(x5,H_(x4,H_(x3,H_(x2,H_(x1,NIL)))))
MDH_((x1,x2,x3,x4,x5,x6)) => H_(x6,H_(x5,H_(x4,H_(x3,H_(x2,H_(x1,NIL))))))
MDH_(NIL) => NIL

MDH(fail-any) => fail-any
MDH(x) => NIL if x ≠ NIL && (forall @gen,@gen_1,@gen_2,@gen_3,@gen_4,@gen_5, x ≠ (@gen_5,@gen_4,@gen_3,@gen_2,@gen_1,@gen)) && (forall @gen_6,@gen_7,@gen_8,@gen_9,@gen_10, x ≠ (@gen_10,@gen_9,@gen_8,@gen_7,@gen_6))
MDH((x1,x2,x3,x4,x5)) => H(x5,H(x4,H(x3,H(x2,H(x1,NIL)))))
MDH((x1,x2,x3,x4,x5,x6)) => H(x6,H(x5,H(x4,H(x3,H(x2,H(x1,NIL))))))
MDH(NIL) => NIL

(v ≥ fail-any) => fail-any
(fail-any ≥ @mayfail_v) => fail-any
(v ≥ v_1) => fail-any if is_not_nat(v_1)
(v ≥ v_1) => fail-any if is_not_nat(v)
(v ≥ v_1) => false if v_1 ≥ v + 1
(v ≥ v_1) => true if v ≥ v_1

(v > fail-any) => fail-any
(fail-any > @mayfail_v) => fail-any
(v > v_1) => fail-any if is_not_nat(v_1)
(v > v_1) => fail-any if is_not_nat(v)
(v > v_1) => false if v_1 ≥ v
(v > v_1) => true if v ≥ v_1 + 1

(v ≤ fail-any) => fail-any
(fail-any ≤ @mayfail_v) => fail-any
(v ≤ v_1) => fail-any if is_not_nat(v)
(v ≤ v_1) => fail-any if is_not_nat(v_1)
(v ≤ v_1) => false if v ≥ v_1 + 1
(v ≤ v_1) => true if v_1 ≥ v

(v < fail-any) => fail-any
(fail-any < @mayfail_v) => fail-any
(v < v_1) => fail-any if is_not_nat(v)
(v < v_1) => fail-any if is_not_nat(v_1)
(v < v_1) => false if v ≥ v_1
(v < v_1) => true if v_1 ≥ v + 1

(fail-any && @mayfail_v) => fail-any
(v && @mayfail_v) => false if v ≠ true
(true && @mayfail_v) => @mayfail_v

Process 0 (that is, the initial process):
(
    {1}!
    {2}new sk: t_sk;
    {3}out(c, pk(sk));
    {4}insert Keys(sk)
) | (
    {5}!
    {87}get Keys(skA: t_sk) in
    {86}get Keys(skB: t_sk) in
    (
        {6}let pkB: t_pk = pk(skB) in
        {7}let pkA: t_pk = pk(skA) in
        {8}if (pk(skA) ≠ pkB) then
        {9}new x: t_exponent;
        {10}new nA: bitstring;
        {11}new sA: bitstring;
        {12}let m1': bitstring = (sA,nA,exp(g,x)) in
        {13}out(c, m1');
        {14}in(c, mC: bitstring);
        {15}let v: bitstring = mC in
        {16}let v_1: bool = ((SA_INIT =nf 1-proj-2-tuple(v)) && success?(1-proj-2-tuple(v))) in
        {17}let ck: bitstring = (if v_1 then 2-proj-2-tuple(v) else caught-fail) in
        {18}let cookie: bitstring = (if v_1 then ck else noCookie) in
        {19}let m1: bitstring = (if (cookie = noCookie) then m1' else (cookie,sA,nA,exp(g,x))) in
        {20}in(c, m2: bitstring);
        {21}let (sB: bitstring,nB: bitstring,gy: G) = m2 in
        {22}if ((gy ≠ g) && not(isCol(gy))) then
        {23}let k1: t_key = KDF(exp(gy,x),(nA,nB),1) in
        {24}let k2: t_key = KDF(exp(gy,x),(nA,nB),2) in
        {25}let kA: t_key = KDF(exp(gy,x),(nA,nB),3) in
        {26}let kB: t_key = KDF(exp(gy,x),(nA,nB),4) in
        {27}let macA: bitstring = MAC(pkA,kA) in
        {28}let macB: bitstring = MAC(pkB,kB) in
        {29}let transcriptA: bitstring = (if (cookie ≠ noCookie) then (cookie,sA,nA,exp(g,x),nB,macA) else (sA,nA,exp(g,x),nB,macA)) in
        {30}let H_1: bitstring = MDH(transcriptA) in
        {31}let T: bitstring = MDH_(transcriptA) in
        {32}event initA(pk(skA),pkB,(nA,nB),(m1,nB),T,H_1);
        {33}event initA2(pk(skA),sA);
        {34}out(c, senc((pkA,sign(H_1,skA)),k1));
        {35}in(c, cipher: bitstring);
        {36}let (=pkB,sm: bitstring) = sdec(cipher,k2) in
        {37}let transcriptB: bitstring = (sB,nB,gy,nA,macB) in
        {38}if signCheck(MDH(transcriptB),sm,pkB) then
        {39}event SanityA((cookie = noCookie),(m1,m2));
        {40}event acceptA(pk(skA),pkB,(nA,nB),(m1,m2),H_1);
        {41}event sessionKeyA(pk(skA),pkB,k1)
    ) | (
        {42}let pkA_1: t_pk = pk(skA) in
        {43}let pkB_1: t_pk = pk(skB) in
        {44}if (pk(skB) ≠ pkA_1) then
        {45}in(c, m1'_1: bitstring);
        {46}new ck_1: bitstring;
        {47}out(c, ck_1);
        {48}in(c, withCookie: bool);
        {49}in(c, mC_1: bitstring);
        {50}let m1_1: bitstring = (if withCookie then mC_1 else m1'_1) in
        {51}let v_2: bool = withCookie in
        {52}let v_3: bitstring = (if v_2 then catch-fail(m1_1) else caught-fail) in
        {53}let v_4: bool = (not-caught-fail(v_3) && ((ck_1 =nf 1-proj-4-tuple(v_3)) && success?(1-proj-4-tuple(v_3)))) in
        {54}let gx: G = (if v_4 then 4-proj-4-tuple(v_3) else caught-fail) in
        {55}let nA_1: bitstring = (if v_4 then 3-proj-4-tuple(v_3) else caught-fail) in
        {56}let sA_1: bitstring = (if v_4 then 2-proj-4-tuple(v_3) else caught-fail) in
        {57}let v_5: bitstring = (if not(v_2) then catch-fail(m1_1) else caught-fail) in
        {58}let v_6: bool = (not-caught-fail(v_5) && success?(1-proj-3-tuple(v_5))) in
        {59}let gx_1: G = (if v_6 then 3-proj-3-tuple(v_5) else caught-fail) in
        {60}let nA_2: bitstring = (if v_6 then 2-proj-3-tuple(v_5) else caught-fail) in
        {61}let sA_2: bitstring = (if v_6 then 1-proj-3-tuple(v_5) else caught-fail) in
        {62}let (sA_3: bitstring,nA_3: bitstring,gx_2: G) = (if v_2 then (if v_4 then (sA_1,nA_1,gx) else fail-any) else (if v_6 then (sA_2,nA_2,gx_1) else fail-any)) in
        {63}if ((gx_2 ≠ g) && not(isCol(gx_2))) then
        {64}new y: t_exponent;
        {65}new nB_1: bitstring;
        {66}new sB_1: bitstring;
        {67}let m2_1: bitstring = (sB_1,nB_1,exp(g,y)) in
        {68}let k1_1: t_key = KDF(exp(gx_2,y),(nA_3,nB_1),1) in
        {69}let k2_1: t_key = KDF(exp(gx_2,y),(nA_3,nB_1),2) in
        {70}let kA_1: t_key = KDF(exp(gx_2,y),(nA_3,nB_1),3) in
        {71}let kB_1: t_key = KDF(exp(gx_2,y),(nA_3,nB_1),4) in
        {72}let macA_1: bitstring = MAC(pkA_1,kA_1) in
        {73}let macB_1: bitstring = MAC(pkB_1,kB_1) in
        {74}let transcriptA_1: bitstring = (if withCookie then (ck_1,sA_3,nA_3,gx_2,nB_1,macA_1) else (sA_3,nA_3,gx_2,nB_1,macA_1)) in
        {75}let H_2: bitstring = MDH(transcriptA_1) in
        {76}event initB(pk(skB),pkA_1,(nA_3,nB_1),(m1_1,nB_1),H_2);
        {77}out(c, m2_1);
        {78}in(c, cipher_1: bitstring);
        {79}let (=pkA_1,sm_1: bitstring) = sdec(cipher_1,k1_1) in
        {80}if signCheck(H_2,sm_1,pkA_1) then
        {81}let T_1: bitstring = MDH_(transcriptA_1) in
        {82}event acceptB(pk(skB),pkA_1,(nA_3,nB_1),(m1_1,nB_1),T_1,H_2);
        {83}event acceptB2(pk(skB),pkA_1,sA_3);
        {84}event sessionKeyB(pk(skB),pkA_1,k1_1);
        {85}event SanityB((withCookie = false),(m1_1,m2_1))
    )
) | (
    {88}!
    {91}get Keys(sk_1: t_sk) in
    {89}event Dishonest(pk(sk_1));
    {90}out(c, sk_1)
)

File "simplified_ikeV2_HF_EC.pv.pv", line 57, character 7:
Warning: identifier A rebound.
File "simplified_ikeV2_HF_EC.pv.pv", line 57, character 14:
Warning: identifier B rebound.
--  Process 1 (that is, process 0, with let moved downwards):
(
    {1}!
    {2}new sk: t_sk;
    {3}out(c, pk(sk));
    {4}insert Keys(sk)
) | (
    {5}!
    {87}get Keys(skA: t_sk) in
    {86}get Keys(skB: t_sk) in
    (
        {6}let pkB: t_pk = pk(skB) in
        {8}if (pk(skA) ≠ pkB) then
        {9}new x: t_exponent;
        {10}new nA: bitstring;
        {11}new sA: bitstring;
        {12}let m1': bitstring = (sA,nA,exp(g,x)) in
        {13}out(c, m1');
        {14}in(c, mC: bitstring);
        {15}let v: bitstring = mC in
        {16}let v_1: bool = ((SA_INIT =nf 1-proj-2-tuple(v)) && success?(1-proj-2-tuple(v))) in
        {17}let ck: bitstring = (if v_1 then 2-proj-2-tuple(v) else caught-fail) in
        {18}let cookie: bitstring = (if v_1 then ck else noCookie) in
        {19}let m1: bitstring = (if (cookie = noCookie) then m1' else (cookie,sA,nA,exp(g,x))) in
        {20}in(c, m2: bitstring);
        {21}let (sB: bitstring,nB: bitstring,gy: G) = m2 in
        {22}if ((gy ≠ g) && not(isCol(gy))) then
        {23}let k1: t_key = KDF(exp(gy,x),(nA,nB),1) in
        {24}let k2: t_key = KDF(exp(gy,x),(nA,nB),2) in
        {25}let kA: t_key = KDF(exp(gy,x),(nA,nB),3) in
        {26}let kB: t_key = KDF(exp(gy,x),(nA,nB),4) in
        {7}let pkA: t_pk = pk(skA) in
        {27}let macA: bitstring = MAC(pkA,kA) in
        {29}let transcriptA: bitstring = (if (cookie ≠ noCookie) then (cookie,sA,nA,exp(g,x),nB,macA) else (sA,nA,exp(g,x),nB,macA)) in
        {30}let H_1: bitstring = MDH(transcriptA) in
        {31}let T: bitstring = MDH_(transcriptA) in
        {32}event initA(pk(skA),pkB,(nA,nB),(m1,nB),T,H_1);
        {33}event initA2(pk(skA),sA);
        {34}out(c, senc((pkA,sign(H_1,skA)),k1));
        {35}in(c, cipher: bitstring);
        {36}let (=pkB,sm: bitstring) = sdec(cipher,k2) in
        {28}let macB: bitstring = MAC(pkB,kB) in
        {37}let transcriptB: bitstring = (sB,nB,gy,nA,macB) in
        {38}if signCheck(MDH(transcriptB),sm,pkB) then
        {39}event SanityA((cookie = noCookie),(m1,m2));
        {40}event acceptA(pk(skA),pkB,(nA,nB),(m1,m2),H_1);
        {41}event sessionKeyA(pk(skA),pkB,k1)
    ) | (
        {42}let pkA_1: t_pk = pk(skA) in
        {44}if (pk(skB) ≠ pkA_1) then
        {45}in(c, m1'_1: bitstring);
        {46}new ck_1: bitstring;
        {47}out(c, ck_1);
        {48}in(c, withCookie: bool);
        {49}in(c, mC_1: bitstring);
        {51}let v_2: bool = withCookie in
        {50}let m1_1: bitstring = (if withCookie then mC_1 else m1'_1) in
        {52}let v_3: bitstring = (if v_2 then catch-fail(m1_1) else caught-fail) in
        {53}let v_4: bool = (not-caught-fail(v_3) && ((ck_1 =nf 1-proj-4-tuple(v_3)) && success?(1-proj-4-tuple(v_3)))) in
        {54}let gx: G = (if v_4 then 4-proj-4-tuple(v_3) else caught-fail) in
        {55}let nA_1: bitstring = (if v_4 then 3-proj-4-tuple(v_3) else caught-fail) in
        {56}let sA_1: bitstring = (if v_4 then 2-proj-4-tuple(v_3) else caught-fail) in
        {57}let v_5: bitstring = (if not(v_2) then catch-fail(m1_1) else caught-fail) in
        {58}let v_6: bool = (not-caught-fail(v_5) && success?(1-proj-3-tuple(v_5))) in
        {59}let gx_1: G = (if v_6 then 3-proj-3-tuple(v_5) else caught-fail) in
        {60}let nA_2: bitstring = (if v_6 then 2-proj-3-tuple(v_5) else caught-fail) in
        {61}let sA_2: bitstring = (if v_6 then 1-proj-3-tuple(v_5) else caught-fail) in
        {62}let (sA_3: bitstring,nA_3: bitstring,gx_2: G) = (if v_2 then (if v_4 then (sA_1,nA_1,gx) else fail-any) else (if v_6 then (sA_2,nA_2,gx_1) else fail-any)) in
        {63}if ((gx_2 ≠ g) && not(isCol(gx_2))) then
        {64}new y: t_exponent;
        {65}new nB_1: bitstring;
        {66}new sB_1: bitstring;
        {67}let m2_1: bitstring = (sB_1,nB_1,exp(g,y)) in
        {68}let k1_1: t_key = KDF(exp(gx_2,y),(nA_3,nB_1),1) in
        {69}let k2_1: t_key = KDF(exp(gx_2,y),(nA_3,nB_1),2) in
        {70}let kA_1: t_key = KDF(exp(gx_2,y),(nA_3,nB_1),3) in
        {71}let kB_1: t_key = KDF(exp(gx_2,y),(nA_3,nB_1),4) in
        {72}let macA_1: bitstring = MAC(pkA_1,kA_1) in
        {74}let transcriptA_1: bitstring = (if withCookie then (ck_1,sA_3,nA_3,gx_2,nB_1,macA_1) else (sA_3,nA_3,gx_2,nB_1,macA_1)) in
        {75}let H_2: bitstring = MDH(transcriptA_1) in
        {76}event initB(pk(skB),pkA_1,(nA_3,nB_1),(m1_1,nB_1),H_2);
        {77}out(c, m2_1);
        {78}in(c, cipher_1: bitstring);
        {79}let (=pkA_1,sm_1: bitstring) = sdec(cipher_1,k1_1) in
        {80}if signCheck(H_2,sm_1,pkA_1) then
        {81}let T_1: bitstring = MDH_(transcriptA_1) in
        {82}event acceptB(pk(skB),pkA_1,(nA_3,nB_1),(m1_1,nB_1),T_1,H_2);
        {83}event acceptB2(pk(skB),pkA_1,sA_3);
        {84}event sessionKeyB(pk(skB),pkA_1,k1_1);
        {85}event SanityB((withCookie = false),(m1_1,m2_1))
    )
) | (
    {88}!
    {91}get Keys(sk_1: t_sk) in
    {89}event Dishonest(pk(sk_1));
    {90}out(c, sk_1)
)

-- Query event(acceptB2(B_1,A_1,sA_4)) ==> event(initA2(A_1,sA_4)) || event(Dishonest(B_1)) || event(Dishonest(A_1)); event(acceptB(B_1,A_1,x_1,y_1,t,h)) ==> event(initA(A_1,B',x',y',t,h')) || event(Dishonest(B_1)) || event(Dishonest(A_1)); event(acceptB(B_1,A_1,x_1,y_1,t,h)) ==> event(initA(A_1,B',x',y',t',h)) || event(Dishonest(B_1)) || event(Dishonest(A_1)); not event(SanityA(true,x_1)); not event(SanityA(false,x_1)); not event(SanityB(true,x_1)); not event(SanityB(false,x_1)); not attacker(secr) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 199 rules (38 with conclusion selected). Queue: 74 rules.
400 rules inserted. Base: 393 rules (61 with conclusion selected). Queue: 159 rules.
600 rules inserted. Base: 561 rules (64 with conclusion selected). Queue: 97 rules.
800 rules inserted. Base: 669 rules (94 with conclusion selected). Queue: 94 rules.
1000 rules inserted. Base: 766 rules (110 with conclusion selected). Queue: 41 rules.
Starting query event(acceptB2(B_1,A_1,sA_4)) ==> event(initA2(A_1,sA_4)) || event(Dishonest(B_1)) || event(Dishonest(A_1))
goal reachable: @sid ≠ @sid_1 && begin(Dishonest(pk(sk_2))) && attacker(sA_4) -> end(acceptB2(pk(sk_3),pk(sk_2),sA_4))
Abbreviations:
sk_3 = sk[!1 = @sid]
sk_2 = sk[!1 = @sid_1]
goal reachable: @sid ≠ @sid_1 && withCookie_1 ≠ true && @sid_2 ≠ @sid && begin(initA2(pk(sk_2),sA_4)) && begin(initA(pk(sk_2),pk(sk_3),(nA_4,nB_2),((sA_4,nA_4,exp_ideal(g,x_1)),nB_2),H_(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,x_1),y_1),(nA_4,nB_2),3)),H_(nB_2,H_(exp_ideal(g,x_1),H_(nA_4,H_(sA_4,NIL))))),H(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,x_1),y_1),(nA_4,nB_2),3)),H(nB_2,H(exp_ideal(g,x_1),H(nA_4,H(sA_4,NIL))))))) && attacker(mC_2) && attacker(withCookie_1) -> end(acceptB2(pk(sk_4),pk(sk_2),sA_4))
Abbreviations:
sk_4 = sk[!1 = @sid_2]
sk_2 = sk[!1 = @sid]
sk_3 = sk[!1 = @sid_1]
sA_4 = sA[skB = sk_3,skA = sk_2,!1 = @sid_3]
nA_4 = nA[skB = sk_3,skA = sk_2,!1 = @sid_3]
x_1 = x[skB = sk_3,skA = sk_2,!1 = @sid_3]
nB_2 = nB_1[mC_1 = mC_2,withCookie = withCookie_1,m1'_1 = (sA_4,nA_4,exp_ideal(g,x_1)),skB = sk_4,skA = sk_2,!1 = @sid_4]
y_1 = y[mC_1 = mC_2,withCookie = withCookie_1,m1'_1 = (sA_4,nA_4,exp_ideal(g,x_1)),skB = sk_4,skA = sk_2,!1 = @sid_4]
goal reachable: @sid ≠ @sid_1 && @sid_2 ≠ @sid && begin(initA2(pk(sk_2),sA_4)) && begin(initA(pk(sk_2),pk(sk_3),(nA_4,nB_2),((ck_2,sA_4,nA_4,exp_ideal(g,x_1)),nB_2),H_(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,x_1),y_1),(nA_4,nB_2),3)),H_(nB_2,H_(exp_ideal(g,x_1),H_(nA_4,H_(sA_4,H_(ck_2,NIL)))))),H(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,x_1),y_1),(nA_4,nB_2),3)),H(nB_2,H(exp_ideal(g,x_1),H(nA_4,H(sA_4,H(ck_2,NIL)))))))) && attacker(m1'_2) -> end(acceptB2(pk(sk_4),pk(sk_2),sA_4))
Abbreviations:
sk_4 = sk[!1 = @sid_2]
sk_2 = sk[!1 = @sid]
sk_3 = sk[!1 = @sid_1]
sA_4 = sA[skB = sk_3,skA = sk_2,!1 = @sid_3]
nA_4 = nA[skB = sk_3,skA = sk_2,!1 = @sid_3]
ck_2 = ck_1[m1'_1 = m1'_2,skB = sk_4,skA = sk_2,!1 = @sid_4]
x_1 = x[skB = sk_3,skA = sk_2,!1 = @sid_3]
nB_2 = nB_1[mC_1 = (ck_2,sA_4,nA_4,exp_ideal(g,x_1)),withCookie = true,m1'_1 = m1'_2,skB = sk_4,skA = sk_2,!1 = @sid_4]
y_1 = y[mC_1 = (ck_2,sA_4,nA_4,exp_ideal(g,x_1)),withCookie = true,m1'_1 = m1'_2,skB = sk_4,skA = sk_2,!1 = @sid_4]
RESULT event(acceptB2(B_1,A_1,sA_4)) ==> event(initA2(A_1,sA_4)) || event(Dishonest(B_1)) || event(Dishonest(A_1)) is true.
Starting query event(acceptB(B_1,A_1,x_1,y_1,t,h)) ==> event(initA(A_1,B',x',y',t,h')) || event(Dishonest(B_1)) || event(Dishonest(A_1))
goal reachable: withCookie_1 ≠ true && @sid ≠ @sid_1 && begin(Dishonest(pk(sk_2))) && attacker(mC_2) && attacker(withCookie_1) && attacker(x1) && attacker(x2) -> end(acceptB(pk(sk_3),pk(sk_2),(x2,nB_2),((x1,x2,weak),nB_2),H_(MAC(pk(sk_2),KDF(weak,(x2,nB_2),3)),H_(nB_2,H_(weak,H_(x2,H_(x1,NIL))))),H(MAC(pk(sk_2),KDF(weak,(x2,nB_2),3)),H(nB_2,H(weak,H(x2,H(x1,NIL)))))))
Abbreviations:
sk_3 = sk[!1 = @sid]
sk_2 = sk[!1 = @sid_1]
nB_2 = nB_1[mC_1 = mC_2,withCookie = withCookie_1,m1'_1 = (x1,x2,weak),skB = sk_3,skA = sk_2,!1 = @sid_2]
goal reachable: withCookie_1 ≠ true && @sid ≠ @sid_1 && begin(Dishonest(pk(sk_2))) && attacker(mC_2) && attacker(withCookie_1) && attacker(x1) && attacker(x2) && attacker(y_1) -> end(acceptB(pk(sk_3),pk(sk_2),(x2,nB_2),((x1,x2,exp_ideal(g,y_1)),nB_2),H_(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,y_2),y_1),(x2,nB_2),3)),H_(nB_2,H_(exp_ideal(g,y_1),H_(x2,H_(x1,NIL))))),H(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,y_2),y_1),(x2,nB_2),3)),H(nB_2,H(exp_ideal(g,y_1),H(x2,H(x1,NIL)))))))
Abbreviations:
sk_3 = sk[!1 = @sid]
sk_2 = sk[!1 = @sid_1]
nB_2 = nB_1[mC_1 = mC_2,withCookie = withCookie_1,m1'_1 = (x1,x2,exp_ideal(g,y_1)),skB = sk_3,skA = sk_2,!1 = @sid_2]
y_2 = y[mC_1 = mC_2,withCookie = withCookie_1,m1'_1 = (x1,x2,exp_ideal(g,y_1)),skB = sk_3,skA = sk_2,!1 = @sid_2]
goal reachable: @sid ≠ @sid_1 && begin(Dishonest(pk(sk_2))) && attacker(x2) && attacker(x3) && attacker(m1'_2) -> end(acceptB(pk(sk_3),pk(sk_2),(x3,nB_2),((ck_2,x2,x3,weak),nB_2),H_(MAC(pk(sk_2),KDF(weak,(x3,nB_2),3)),H_(nB_2,H_(weak,H_(x3,H_(x2,H_(ck_2,NIL)))))),H(MAC(pk(sk_2),KDF(weak,(x3,nB_2),3)),H(nB_2,H(weak,H(x3,H(x2,H(ck_2,NIL))))))))
Abbreviations:
sk_3 = sk[!1 = @sid]
sk_2 = sk[!1 = @sid_1]
ck_2 = ck_1[m1'_1 = m1'_2,skB = sk_3,skA = sk_2,!1 = @sid_2]
nB_2 = nB_1[mC_1 = (ck_2,x2,x3,weak),withCookie = true,m1'_1 = m1'_2,skB = sk_3,skA = sk_2,!1 = @sid_2]
goal reachable: @sid ≠ @sid_1 && begin(Dishonest(pk(sk_2))) && attacker(x2) && attacker(x3) && attacker(y_1) && attacker(m1'_2) -> end(acceptB(pk(sk_3),pk(sk_2),(x3,nB_2),((ck_2,x2,x3,exp_ideal(g,y_1)),nB_2),H_(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,y_2),y_1),(x3,nB_2),3)),H_(nB_2,H_(exp_ideal(g,y_1),H_(x3,H_(x2,H_(ck_2,NIL)))))),H(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,y_2),y_1),(x3,nB_2),3)),H(nB_2,H(exp_ideal(g,y_1),H(x3,H(x2,H(ck_2,NIL))))))))
Abbreviations:
sk_3 = sk[!1 = @sid]
sk_2 = sk[!1 = @sid_1]
ck_2 = ck_1[m1'_1 = m1'_2,skB = sk_3,skA = sk_2,!1 = @sid_2]
nB_2 = nB_1[mC_1 = (ck_2,x2,x3,exp_ideal(g,y_1)),withCookie = true,m1'_1 = m1'_2,skB = sk_3,skA = sk_2,!1 = @sid_2]
y_2 = y[mC_1 = (ck_2,x2,x3,exp_ideal(g,y_1)),withCookie = true,m1'_1 = m1'_2,skB = sk_3,skA = sk_2,!1 = @sid_2]
goal reachable: @sid ≠ @sid_1 && withCookie_1 ≠ true && @sid_2 ≠ @sid && begin(initA2(pk(sk_2),sA_4)) && begin(initA(pk(sk_2),pk(sk_3),(nA_4,nB_2),((sA_4,nA_4,exp_ideal(g,x_1)),nB_2),H_(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,x_1),y_1),(nA_4,nB_2),3)),H_(nB_2,H_(exp_ideal(g,x_1),H_(nA_4,H_(sA_4,NIL))))),H(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,x_1),y_1),(nA_4,nB_2),3)),H(nB_2,H(exp_ideal(g,x_1),H(nA_4,H(sA_4,NIL))))))) && attacker(mC_2) && attacker(withCookie_1) -> end(acceptB(pk(sk_4),pk(sk_2),(nA_4,nB_2),((sA_4,nA_4,exp_ideal(g,x_1)),nB_2),H_(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,x_1),y_1),(nA_4,nB_2),3)),H_(nB_2,H_(exp_ideal(g,x_1),H_(nA_4,H_(sA_4,NIL))))),H(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,x_1),y_1),(nA_4,nB_2),3)),H(nB_2,H(exp_ideal(g,x_1),H(nA_4,H(sA_4,NIL)))))))
Abbreviations:
sk_4 = sk[!1 = @sid_2]
sk_2 = sk[!1 = @sid]
sk_3 = sk[!1 = @sid_1]
nA_4 = nA[skB = sk_3,skA = sk_2,!1 = @sid_3]
sA_4 = sA[skB = sk_3,skA = sk_2,!1 = @sid_3]
x_1 = x[skB = sk_3,skA = sk_2,!1 = @sid_3]
nB_2 = nB_1[mC_1 = mC_2,withCookie = withCookie_1,m1'_1 = (sA_4,nA_4,exp_ideal(g,x_1)),skB = sk_4,skA = sk_2,!1 = @sid_4]
y_1 = y[mC_1 = mC_2,withCookie = withCookie_1,m1'_1 = (sA_4,nA_4,exp_ideal(g,x_1)),skB = sk_4,skA = sk_2,!1 = @sid_4]
goal reachable: @sid ≠ @sid_1 && @sid_2 ≠ @sid && begin(initA2(pk(sk_2),sA_4)) && begin(initA(pk(sk_2),pk(sk_3),(nA_4,nB_2),((ck_2,sA_4,nA_4,exp_ideal(g,x_1)),nB_2),H_(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,x_1),y_1),(nA_4,nB_2),3)),H_(nB_2,H_(exp_ideal(g,x_1),H_(nA_4,H_(sA_4,H_(ck_2,NIL)))))),H(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,x_1),y_1),(nA_4,nB_2),3)),H(nB_2,H(exp_ideal(g,x_1),H(nA_4,H(sA_4,H(ck_2,NIL)))))))) && attacker(m1'_2) -> end(acceptB(pk(sk_4),pk(sk_2),(nA_4,nB_2),((ck_2,sA_4,nA_4,exp_ideal(g,x_1)),nB_2),H_(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,x_1),y_1),(nA_4,nB_2),3)),H_(nB_2,H_(exp_ideal(g,x_1),H_(nA_4,H_(sA_4,H_(ck_2,NIL)))))),H(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,x_1),y_1),(nA_4,nB_2),3)),H(nB_2,H(exp_ideal(g,x_1),H(nA_4,H(sA_4,H(ck_2,NIL))))))))
Abbreviations:
sk_4 = sk[!1 = @sid_2]
sk_2 = sk[!1 = @sid]
sk_3 = sk[!1 = @sid_1]
nA_4 = nA[skB = sk_3,skA = sk_2,!1 = @sid_3]
ck_2 = ck_1[m1'_1 = m1'_2,skB = sk_4,skA = sk_2,!1 = @sid_4]
sA_4 = sA[skB = sk_3,skA = sk_2,!1 = @sid_3]
x_1 = x[skB = sk_3,skA = sk_2,!1 = @sid_3]
nB_2 = nB_1[mC_1 = (ck_2,sA_4,nA_4,exp_ideal(g,x_1)),withCookie = true,m1'_1 = m1'_2,skB = sk_4,skA = sk_2,!1 = @sid_4]
y_1 = y[mC_1 = (ck_2,sA_4,nA_4,exp_ideal(g,x_1)),withCookie = true,m1'_1 = m1'_2,skB = sk_4,skA = sk_2,!1 = @sid_4]
RESULT event(acceptB(B_1,A_1,x_1,y_1,t,h)) ==> event(initA(A_1,B',x',y',t,h')) || event(Dishonest(B_1)) || event(Dishonest(A_1)) is true.
Starting query event(acceptB(B_1,A_1,x_1,y_1,t,h)) ==> event(initA(A_1,B',x',y',t',h)) || event(Dishonest(B_1)) || event(Dishonest(A_1))
goal reachable: withCookie_1 ≠ true && @sid ≠ @sid_1 && begin(Dishonest(pk(sk_2))) && attacker(mC_2) && attacker(withCookie_1) && attacker(x1) && attacker(x2) -> end(acceptB(pk(sk_3),pk(sk_2),(x2,nB_2),((x1,x2,weak),nB_2),H_(MAC(pk(sk_2),KDF(weak,(x2,nB_2),3)),H_(nB_2,H_(weak,H_(x2,H_(x1,NIL))))),H(MAC(pk(sk_2),KDF(weak,(x2,nB_2),3)),H(nB_2,H(weak,H(x2,H(x1,NIL)))))))
Abbreviations:
sk_3 = sk[!1 = @sid]
sk_2 = sk[!1 = @sid_1]
nB_2 = nB_1[mC_1 = mC_2,withCookie = withCookie_1,m1'_1 = (x1,x2,weak),skB = sk_3,skA = sk_2,!1 = @sid_2]
goal reachable: withCookie_1 ≠ true && @sid ≠ @sid_1 && begin(Dishonest(pk(sk_2))) && attacker(mC_2) && attacker(withCookie_1) && attacker(x1) && attacker(x2) && attacker(y_1) -> end(acceptB(pk(sk_3),pk(sk_2),(x2,nB_2),((x1,x2,exp_ideal(g,y_1)),nB_2),H_(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,y_2),y_1),(x2,nB_2),3)),H_(nB_2,H_(exp_ideal(g,y_1),H_(x2,H_(x1,NIL))))),H(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,y_2),y_1),(x2,nB_2),3)),H(nB_2,H(exp_ideal(g,y_1),H(x2,H(x1,NIL)))))))
Abbreviations:
sk_3 = sk[!1 = @sid]
sk_2 = sk[!1 = @sid_1]
nB_2 = nB_1[mC_1 = mC_2,withCookie = withCookie_1,m1'_1 = (x1,x2,exp_ideal(g,y_1)),skB = sk_3,skA = sk_2,!1 = @sid_2]
y_2 = y[mC_1 = mC_2,withCookie = withCookie_1,m1'_1 = (x1,x2,exp_ideal(g,y_1)),skB = sk_3,skA = sk_2,!1 = @sid_2]
goal reachable: @sid ≠ @sid_1 && begin(Dishonest(pk(sk_2))) && attacker(x2) && attacker(x3) && attacker(m1'_2) -> end(acceptB(pk(sk_3),pk(sk_2),(x3,nB_2),((ck_2,x2,x3,weak),nB_2),H_(MAC(pk(sk_2),KDF(weak,(x3,nB_2),3)),H_(nB_2,H_(weak,H_(x3,H_(x2,H_(ck_2,NIL)))))),H(MAC(pk(sk_2),KDF(weak,(x3,nB_2),3)),H(nB_2,H(weak,H(x3,H(x2,H(ck_2,NIL))))))))
Abbreviations:
sk_3 = sk[!1 = @sid]
sk_2 = sk[!1 = @sid_1]
ck_2 = ck_1[m1'_1 = m1'_2,skB = sk_3,skA = sk_2,!1 = @sid_2]
nB_2 = nB_1[mC_1 = (ck_2,x2,x3,weak),withCookie = true,m1'_1 = m1'_2,skB = sk_3,skA = sk_2,!1 = @sid_2]
goal reachable: @sid ≠ @sid_1 && begin(Dishonest(pk(sk_2))) && attacker(x2) && attacker(x3) && attacker(y_1) && attacker(m1'_2) -> end(acceptB(pk(sk_3),pk(sk_2),(x3,nB_2),((ck_2,x2,x3,exp_ideal(g,y_1)),nB_2),H_(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,y_2),y_1),(x3,nB_2),3)),H_(nB_2,H_(exp_ideal(g,y_1),H_(x3,H_(x2,H_(ck_2,NIL)))))),H(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,y_2),y_1),(x3,nB_2),3)),H(nB_2,H(exp_ideal(g,y_1),H(x3,H(x2,H(ck_2,NIL))))))))
Abbreviations:
sk_3 = sk[!1 = @sid]
sk_2 = sk[!1 = @sid_1]
ck_2 = ck_1[m1'_1 = m1'_2,skB = sk_3,skA = sk_2,!1 = @sid_2]
nB_2 = nB_1[mC_1 = (ck_2,x2,x3,exp_ideal(g,y_1)),withCookie = true,m1'_1 = m1'_2,skB = sk_3,skA = sk_2,!1 = @sid_2]
y_2 = y[mC_1 = (ck_2,x2,x3,exp_ideal(g,y_1)),withCookie = true,m1'_1 = m1'_2,skB = sk_3,skA = sk_2,!1 = @sid_2]
goal reachable: @sid ≠ @sid_1 && withCookie_1 ≠ true && @sid_2 ≠ @sid && begin(initA2(pk(sk_2),sA_4)) && begin(initA(pk(sk_2),pk(sk_3),(nA_4,nB_2),((sA_4,nA_4,exp_ideal(g,x_1)),nB_2),H_(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,x_1),y_1),(nA_4,nB_2),3)),H_(nB_2,H_(exp_ideal(g,x_1),H_(nA_4,H_(sA_4,NIL))))),H(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,x_1),y_1),(nA_4,nB_2),3)),H(nB_2,H(exp_ideal(g,x_1),H(nA_4,H(sA_4,NIL))))))) && attacker(mC_2) && attacker(withCookie_1) -> end(acceptB(pk(sk_4),pk(sk_2),(nA_4,nB_2),((sA_4,nA_4,exp_ideal(g,x_1)),nB_2),H_(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,x_1),y_1),(nA_4,nB_2),3)),H_(nB_2,H_(exp_ideal(g,x_1),H_(nA_4,H_(sA_4,NIL))))),H(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,x_1),y_1),(nA_4,nB_2),3)),H(nB_2,H(exp_ideal(g,x_1),H(nA_4,H(sA_4,NIL)))))))
Abbreviations:
sk_4 = sk[!1 = @sid_2]
sk_2 = sk[!1 = @sid]
sk_3 = sk[!1 = @sid_1]
nA_4 = nA[skB = sk_3,skA = sk_2,!1 = @sid_3]
sA_4 = sA[skB = sk_3,skA = sk_2,!1 = @sid_3]
x_1 = x[skB = sk_3,skA = sk_2,!1 = @sid_3]
nB_2 = nB_1[mC_1 = mC_2,withCookie = withCookie_1,m1'_1 = (sA_4,nA_4,exp_ideal(g,x_1)),skB = sk_4,skA = sk_2,!1 = @sid_4]
y_1 = y[mC_1 = mC_2,withCookie = withCookie_1,m1'_1 = (sA_4,nA_4,exp_ideal(g,x_1)),skB = sk_4,skA = sk_2,!1 = @sid_4]
goal reachable: @sid ≠ @sid_1 && @sid_2 ≠ @sid && begin(initA2(pk(sk_2),sA_4)) && begin(initA(pk(sk_2),pk(sk_3),(nA_4,nB_2),((ck_2,sA_4,nA_4,exp_ideal(g,x_1)),nB_2),H_(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,x_1),y_1),(nA_4,nB_2),3)),H_(nB_2,H_(exp_ideal(g,x_1),H_(nA_4,H_(sA_4,H_(ck_2,NIL)))))),H(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,x_1),y_1),(nA_4,nB_2),3)),H(nB_2,H(exp_ideal(g,x_1),H(nA_4,H(sA_4,H(ck_2,NIL)))))))) && attacker(m1'_2) -> end(acceptB(pk(sk_4),pk(sk_2),(nA_4,nB_2),((ck_2,sA_4,nA_4,exp_ideal(g,x_1)),nB_2),H_(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,x_1),y_1),(nA_4,nB_2),3)),H_(nB_2,H_(exp_ideal(g,x_1),H_(nA_4,H_(sA_4,H_(ck_2,NIL)))))),H(MAC(pk(sk_2),KDF(exp_ideal(exp_ideal(g,x_1),y_1),(nA_4,nB_2),3)),H(nB_2,H(exp_ideal(g,x_1),H(nA_4,H(sA_4,H(ck_2,NIL))))))))
Abbreviations:
sk_4 = sk[!1 = @sid_2]
sk_2 = sk[!1 = @sid]
sk_3 = sk[!1 = @sid_1]
nA_4 = nA[skB = sk_3,skA = sk_2,!1 = @sid_3]
ck_2 = ck_1[m1'_1 = m1'_2,skB = sk_4,skA = sk_2,!1 = @sid_4]
sA_4 = sA[skB = sk_3,skA = sk_2,!1 = @sid_3]
x_1 = x[skB = sk_3,skA = sk_2,!1 = @sid_3]
nB_2 = nB_1[mC_1 = (ck_2,sA_4,nA_4,exp_ideal(g,x_1)),withCookie = true,m1'_1 = m1'_2,skB = sk_4,skA = sk_2,!1 = @sid_4]
y_1 = y[mC_1 = (ck_2,sA_4,nA_4,exp_ideal(g,x_1)),withCookie = true,m1'_1 = m1'_2,skB = sk_4,skA = sk_2,!1 = @sid_4]
RESULT event(acceptB(B_1,A_1,x_1,y_1,t,h)) ==> event(initA(A_1,B',x',y',t',h)) || event(Dishonest(B_1)) || event(Dishonest(A_1)) is true.
Starting query not event(SanityA(true,x_1))
goal reachable: @sid ≠ @sid_1 && begin(Dishonest(pk(sk_2))) && begin(initA2(pk(sk_3),sA_4)) && begin(initA(pk(sk_3),pk(sk_2),(nA_4,x2),((sA_4,nA_4,exp_ideal(g,x_1)),x2),H_(MAC(pk(sk_3),KDF(weak,(nA_4,x2),3)),H_(x2,H_(exp_ideal(g,x_1),H_(nA_4,H_(sA_4,NIL))))),H(MAC(pk(sk_3),KDF(weak,(nA_4,x2),3)),H(x2,H(exp_ideal(g,x_1),H(nA_4,H(sA_4,NIL))))))) && attacker(x1) && attacker(x2) -> end(SanityA(true,((sA_4,nA_4,exp_ideal(g,x_1)),(x1,x2,weak))))
Abbreviations:
sk_2 = sk[!1 = @sid_1]
sk_3 = sk[!1 = @sid]
sA_4 = sA[skB = sk_2,skA = sk_3,!1 = @sid_2]
nA_4 = nA[skB = sk_2,skA = sk_3,!1 = @sid_2]
x_1 = x[skB = sk_2,skA = sk_3,!1 = @sid_2]

Derivation:
Abbreviations:
sk_2 = sk[!1 = @sid]
sk_3 = sk[!1 = @sid_1]
sA_4 = sA[skB = sk_2,skA = sk_3,!1 = @sid_2]
nA_4 = nA[skB = sk_2,skA = sk_3,!1 = @sid_2]
x_1 = x[skB = sk_2,skA = sk_3,!1 = @sid_2]

1. The entry Keys(sk_3) may be inserted in a table at insert {4}.
table(Keys(sk_3)).

2. The entry Keys(sk_2) may be inserted in a table at insert {4}.
table(Keys(sk_2)).

3. The attacker has some term mC_2.
attacker(mC_2).

4. Using the function weak the attacker may obtain weak.
attacker(weak).

5. We assume as hypothesis that
attacker(x2).

6. We assume as hypothesis that
attacker(x1).

7. By 6, the attacker may know x1.
By 5, the attacker may know x2.
By 4, the attacker may know weak.
Using the function 3-tuple the attacker may obtain (x1,x2,weak).
attacker((x1,x2,weak)).

8. Using the function 0 the attacker may obtain 0.
attacker(0).

9. By 8, the attacker may know 0.
Using the function + the attacker may obtain 1.
attacker(1).

10. By 9, the attacker may know 1.
Using the function + the attacker may obtain 2.
attacker(2).

11. The entry Keys(sk_3) that may be in a table by 1 may be read at get {87}.
The entry Keys(sk_2) that may be in a table by 2 may be read at get {86}.
We have sk_3 ≠ sk_2.
So the message (sA_4,nA_4,exp_ideal(g,x_1)) may be sent to the attacker at output {13}.
attacker((sA_4,nA_4,exp_ideal(g,x_1))).

12. By 11, the attacker may know (sA_4,nA_4,exp_ideal(g,x_1)).
Using the function 2-proj-3-tuple the attacker may obtain nA_4.
attacker(nA_4).

13. By 12, the attacker may know nA_4.
By 5, the attacker may know x2.
Using the function 2-tuple the attacker may obtain (nA_4,x2).
attacker((nA_4,x2)).

14. By 4, the attacker may know weak.
By 13, the attacker may know (nA_4,x2).
By 10, the attacker may know 2.
Using the function KDF the attacker may obtain KDF(weak,(nA_4,x2),2).
attacker(KDF(weak,(nA_4,x2),2)).

15. The entry Keys(sk_2) that may be in a table by 2 may be read at get {91}.
The event Dishonest(pk(sk_2)) may be executed at {89}.
So the message sk_2 may be sent to the attacker at output {90}.
attacker(sk_2).

16. By 10, the attacker may know 2.
Using the function + the attacker may obtain 3.
attacker(3).

17. By 16, the attacker may know 3.
Using the function + the attacker may obtain 4.
attacker(4).

18. By 4, the attacker may know weak.
By 13, the attacker may know (nA_4,x2).
By 17, the attacker may know 4.
Using the function KDF the attacker may obtain KDF(weak,(nA_4,x2),4).
attacker(KDF(weak,(nA_4,x2),4)).

19. By 15, the attacker may know sk_2.
Using the function pk the attacker may obtain pk(sk_2).
attacker(pk(sk_2)).

20. By 19, the attacker may know pk(sk_2).
By 18, the attacker may know KDF(weak,(nA_4,x2),4).
Using the function MAC the attacker may obtain MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)).
attacker(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4))).

21. By 6, the attacker may know x1.
By 5, the attacker may know x2.
By 4, the attacker may know weak.
By 12, the attacker may know nA_4.
By 20, the attacker may know MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)).
Using the function 5-tuple the attacker may obtain (x1,x2,weak,nA_4,MAC(pk(sk_2),KDF(weak,(nA_4,x2),4))).
attacker((x1,x2,weak,nA_4,MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)))).

22. By 21, the attacker may know (x1,x2,weak,nA_4,MAC(pk(sk_2),KDF(weak,(nA_4,x2),4))).
Using the function MDH the attacker may obtain H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1,NIL))))).
attacker(H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1,NIL)))))).

23. By 22, the attacker may know H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1,NIL))))).
By 15, the attacker may know sk_2.
Using the function sign the attacker may obtain sign(H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1,NIL))))),sk_2).
attacker(sign(H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1,NIL))))),sk_2)).

24. By 19, the attacker may know pk(sk_2).
By 23, the attacker may know sign(H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1,NIL))))),sk_2).
Using the function 2-tuple the attacker may obtain (pk(sk_2),sign(H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1,NIL))))),sk_2)).
attacker((pk(sk_2),sign(H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1,NIL))))),sk_2))).

25. By 24, the attacker may know (pk(sk_2),sign(H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1,NIL))))),sk_2)).
By 14, the attacker may know KDF(weak,(nA_4,x2),2).
Using the function senc the attacker may obtain senc((pk(sk_2),sign(H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1,NIL))))),sk_2)),KDF(weak,(nA_4,x2),2)).
attacker(senc((pk(sk_2),sign(H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1,NIL))))),sk_2)),KDF(weak,(nA_4,x2),2))).

26. The entry Keys(sk_3) that may be in a table by 1 may be read at get {87}.
The entry Keys(sk_2) that may be in a table by 2 may be read at get {86}.
The message mC_2 that the attacker may have by 3 may be received at input {14}.
The message (x1,x2,weak) that the attacker may have by 7 may be received at input {20}.
The event initA(pk(sk_3),pk(sk_2),(nA_4,x2),((sA_4,nA_4,exp_ideal(g,x_1)),x2),H_(MAC(pk(sk_3),KDF(weak,(nA_4,x2),3)),H_(x2,H_(exp_ideal(g,x_1),H_(nA_4,H_(sA_4,NIL))))),H(MAC(pk(sk_3),KDF(weak,(nA_4,x2),3)),H(x2,H(exp_ideal(g,x_1),H(nA_4,H(sA_4,NIL)))))) may be executed at {32}.
The event initA2(pk(sk_3),sA_4) may be executed at {33}.
The message senc((pk(sk_2),sign(H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1,NIL))))),sk_2)),KDF(weak,(nA_4,x2),2)) that the attacker may have by 25 may be received at input {35}.
We have (forall @gen,@gen_1, mC_2 ≠ (@gen_1,@gen)) && sk_3 ≠ sk_2.
So event SanityA(true,((sA_4,nA_4,exp_ideal(g,x_1)),(x1,x2,weak))) may be executed at {39}.
end(SanityA(true,((sA_4,nA_4,exp_ideal(g,x_1)),(x1,x2,weak)))).

27. By 26, end(SanityA(true,((sA_4,nA_4,exp_ideal(g,x_1)),(x1,x2,weak)))).
The goal is reached, represented in the following fact:
end(SanityA(true,((sA_4,nA_4,exp_ideal(g,x_1)),(x1,x2,weak)))).


A more detailed output of the traces is available with
  set traceDisplay = long.

new sk: t_sk creating sk_2 at {2} in copy a

out(c, ~M) with ~M = pk(sk_2) at {3} in copy a

insert Keys(sk_2) at {4} in copy a

new sk: t_sk creating sk_3 at {2} in copy a_1

out(c, ~M_1) with ~M_1 = pk(sk_3) at {3} in copy a_1

insert Keys(sk_3) at {4} in copy a_1

get Keys(sk_2) at {87} in copy a_2

get Keys(sk_3) at {86} in copy a_2

new x: t_exponent creating x_1 at {9} in copy a_2

new nA: bitstring creating nA_4 at {10} in copy a_2

new sA: bitstring creating sA_4 at {11} in copy a_2

out(c, (~M_2,~M_3,~M_4)) with ~M_2 = sA_4, ~M_3 = nA_4, ~M_4 = exp_ideal(g,x_1) at {13} in copy a_2

in(c, a_3) at {14} in copy a_2

in(c, (a_4,a_5,weak)) at {20} in copy a_2

event initA(pk(sk_2),pk(sk_3),(nA_4,a_5),((sA_4,nA_4,exp_ideal(g,x_1)),a_5),H_(MAC(pk(sk_2),KDF(weak,(nA_4,a_5),3)),H_(a_5,H_(exp_ideal(g,x_1),H_(nA_4,H_(sA_4,NIL))))),H(MAC(pk(sk_2),KDF(weak,(nA_4,a_5),3)),H(a_5,H(exp_ideal(g,x_1),H(nA_4,H(sA_4,NIL)))))) at {32} in copy a_2

event initA2(pk(sk_2),sA_4) at {33} in copy a_2

out(c, ~M_5) with ~M_5 = senc((pk(sk_2),sign(H(MAC(pk(sk_2),KDF(weak,(nA_4,a_5),3)),H(a_5,H(exp_ideal(g,x_1),H(nA_4,H(sA_4,NIL))))),sk_2)),KDF(weak,(nA_4,a_5),1)) at {34} in copy a_2

get Keys(sk_3) at {91} in copy a_6

event Dishonest(pk(sk_3)) at {89} in copy a_6

out(c, ~M_6) with ~M_6 = sk_3 at {90} in copy a_6

in(c, senc((~M_1,sign(MDH((a_4,a_5,weak,~M_3,MAC(~M_1,KDF(weak,(~M_3,a_5),4)))),~M_6)),KDF(weak,(~M_3,a_5),2))) with senc((~M_1,sign(MDH((a_4,a_5,weak,~M_3,MAC(~M_1,KDF(weak,(~M_3,a_5),4)))),~M_6)),KDF(weak,(~M_3,a_5),2)) = senc((pk(sk_3),sign(H(MAC(pk(sk_3),KDF(weak,(nA_4,a_5),4)),H(nA_4,H(weak,H(a_5,H(a_4,NIL))))),sk_3)),KDF(weak,(nA_4,a_5),2)) at {35} in copy a_2

event SanityA(true,((sA_4,nA_4,exp_ideal(g,x_1)),(a_4,a_5,weak))) at {39} in copy a_2 (goal)

The event SanityA(true,((sA_4,nA_4,exp_ideal(g,x_1)),(a_4,a_5,weak))) is executed at {39} in copy a_2.
A trace has been found.
RESULT not event(SanityA(true,x_1)) is false.
Starting query not event(SanityA(false,x_1))
goal reachable: x1 ≠ noCookie && @sid ≠ @sid_1 && begin(Dishonest(pk(sk_2))) && begin(initA2(pk(sk_3),sA_4)) && begin(initA(pk(sk_3),pk(sk_2),(nA_4,x2),((x1,sA_4,nA_4,exp_ideal(g,x_1)),x2),H_(MAC(pk(sk_3),KDF(weak,(nA_4,x2),3)),H_(x2,H_(exp_ideal(g,x_1),H_(nA_4,H_(sA_4,H_(x1,NIL)))))),H(MAC(pk(sk_3),KDF(weak,(nA_4,x2),3)),H(x2,H(exp_ideal(g,x_1),H(nA_4,H(sA_4,H(x1,NIL)))))))) && attacker(x1_1) && attacker(x2) && attacker(x1) -> end(SanityA(false,((x1,sA_4,nA_4,exp_ideal(g,x_1)),(x1_1,x2,weak))))
Abbreviations:
sk_2 = sk[!1 = @sid_1]
sk_3 = sk[!1 = @sid]
sA_4 = sA[skB = sk_2,skA = sk_3,!1 = @sid_2]
nA_4 = nA[skB = sk_2,skA = sk_3,!1 = @sid_2]
x_1 = x[skB = sk_2,skA = sk_3,!1 = @sid_2]

Derivation:
Abbreviations:
sk_2 = sk[!1 = @sid]
sk_3 = sk[!1 = @sid_1]
sA_4 = sA[skB = sk_2,skA = sk_3,!1 = @sid_2]
nA_4 = nA[skB = sk_2,skA = sk_3,!1 = @sid_2]
x_1 = x[skB = sk_2,skA = sk_3,!1 = @sid_2]

1. The entry Keys(sk_3) may be inserted in a table at insert {4}.
table(Keys(sk_3)).

2. The entry Keys(sk_2) may be inserted in a table at insert {4}.
table(Keys(sk_2)).

3. We assume as hypothesis that
attacker(x1).

4. Using the function SA_INIT the attacker may obtain SA_INIT.
attacker(SA_INIT).

5. By 4, the attacker may know SA_INIT.
By 3, the attacker may know x1.
Using the function 2-tuple the attacker may obtain (SA_INIT,x1).
attacker((SA_INIT,x1)).

6. Using the function weak the attacker may obtain weak.
attacker(weak).

7. We assume as hypothesis that
attacker(x2).

8. We assume as hypothesis that
attacker(x1_1).

9. By 8, the attacker may know x1_1.
By 7, the attacker may know x2.
By 6, the attacker may know weak.
Using the function 3-tuple the attacker may obtain (x1_1,x2,weak).
attacker((x1_1,x2,weak)).

10. Using the function 0 the attacker may obtain 0.
attacker(0).

11. By 10, the attacker may know 0.
Using the function + the attacker may obtain 1.
attacker(1).

12. By 11, the attacker may know 1.
Using the function + the attacker may obtain 2.
attacker(2).

13. The entry Keys(sk_3) that may be in a table by 1 may be read at get {87}.
The entry Keys(sk_2) that may be in a table by 2 may be read at get {86}.
We have sk_3 ≠ sk_2.
So the message (sA_4,nA_4,exp_ideal(g,x_1)) may be sent to the attacker at output {13}.
attacker((sA_4,nA_4,exp_ideal(g,x_1))).

14. By 13, the attacker may know (sA_4,nA_4,exp_ideal(g,x_1)).
Using the function 2-proj-3-tuple the attacker may obtain nA_4.
attacker(nA_4).

15. By 14, the attacker may know nA_4.
By 7, the attacker may know x2.
Using the function 2-tuple the attacker may obtain (nA_4,x2).
attacker((nA_4,x2)).

16. By 6, the attacker may know weak.
By 15, the attacker may know (nA_4,x2).
By 12, the attacker may know 2.
Using the function KDF the attacker may obtain KDF(weak,(nA_4,x2),2).
attacker(KDF(weak,(nA_4,x2),2)).

17. The entry Keys(sk_2) that may be in a table by 2 may be read at get {91}.
The event Dishonest(pk(sk_2)) may be executed at {89}.
So the message sk_2 may be sent to the attacker at output {90}.
attacker(sk_2).

18. By 12, the attacker may know 2.
Using the function + the attacker may obtain 3.
attacker(3).

19. By 18, the attacker may know 3.
Using the function + the attacker may obtain 4.
attacker(4).

20. By 6, the attacker may know weak.
By 15, the attacker may know (nA_4,x2).
By 19, the attacker may know 4.
Using the function KDF the attacker may obtain KDF(weak,(nA_4,x2),4).
attacker(KDF(weak,(nA_4,x2),4)).

21. By 17, the attacker may know sk_2.
Using the function pk the attacker may obtain pk(sk_2).
attacker(pk(sk_2)).

22. By 21, the attacker may know pk(sk_2).
By 20, the attacker may know KDF(weak,(nA_4,x2),4).
Using the function MAC the attacker may obtain MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)).
attacker(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4))).

23. By 8, the attacker may know x1_1.
By 7, the attacker may know x2.
By 6, the attacker may know weak.
By 14, the attacker may know nA_4.
By 22, the attacker may know MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)).
Using the function 5-tuple the attacker may obtain (x1_1,x2,weak,nA_4,MAC(pk(sk_2),KDF(weak,(nA_4,x2),4))).
attacker((x1_1,x2,weak,nA_4,MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)))).

24. By 23, the attacker may know (x1_1,x2,weak,nA_4,MAC(pk(sk_2),KDF(weak,(nA_4,x2),4))).
Using the function MDH the attacker may obtain H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1_1,NIL))))).
attacker(H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1_1,NIL)))))).

25. By 24, the attacker may know H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1_1,NIL))))).
By 17, the attacker may know sk_2.
Using the function sign the attacker may obtain sign(H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1_1,NIL))))),sk_2).
attacker(sign(H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1_1,NIL))))),sk_2)).

26. By 21, the attacker may know pk(sk_2).
By 25, the attacker may know sign(H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1_1,NIL))))),sk_2).
Using the function 2-tuple the attacker may obtain (pk(sk_2),sign(H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1_1,NIL))))),sk_2)).
attacker((pk(sk_2),sign(H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1_1,NIL))))),sk_2))).

27. By 26, the attacker may know (pk(sk_2),sign(H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1_1,NIL))))),sk_2)).
By 16, the attacker may know KDF(weak,(nA_4,x2),2).
Using the function senc the attacker may obtain senc((pk(sk_2),sign(H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1_1,NIL))))),sk_2)),KDF(weak,(nA_4,x2),2)).
attacker(senc((pk(sk_2),sign(H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1_1,NIL))))),sk_2)),KDF(weak,(nA_4,x2),2))).

28. The entry Keys(sk_3) that may be in a table by 1 may be read at get {87}.
The entry Keys(sk_2) that may be in a table by 2 may be read at get {86}.
The message (SA_INIT,x1) that the attacker may have by 5 may be received at input {14}.
The message (x1_1,x2,weak) that the attacker may have by 9 may be received at input {20}.
The event initA(pk(sk_3),pk(sk_2),(nA_4,x2),((x1,sA_4,nA_4,exp_ideal(g,x_1)),x2),H_(MAC(pk(sk_3),KDF(weak,(nA_4,x2),3)),H_(x2,H_(exp_ideal(g,x_1),H_(nA_4,H_(sA_4,H_(x1,NIL)))))),H(MAC(pk(sk_3),KDF(weak,(nA_4,x2),3)),H(x2,H(exp_ideal(g,x_1),H(nA_4,H(sA_4,H(x1,NIL))))))) may be executed at {32}.
The event initA2(pk(sk_3),sA_4) may be executed at {33}.
The message senc((pk(sk_2),sign(H(MAC(pk(sk_2),KDF(weak,(nA_4,x2),4)),H(nA_4,H(weak,H(x2,H(x1_1,NIL))))),sk_2)),KDF(weak,(nA_4,x2),2)) that the attacker may have by 27 may be received at input {35}.
We have x1 ≠ noCookie && sk_3 ≠ sk_2.
So event SanityA(false,((x1,sA_4,nA_4,exp_ideal(g,x_1)),(x1_1,x2,weak))) may be executed at {39}.
end(SanityA(false,((x1,sA_4,nA_4,exp_ideal(g,x_1)),(x1_1,x2,weak)))).

29. By 28, end(SanityA(false,((x1,sA_4,nA_4,exp_ideal(g,x_1)),(x1_1,x2,weak)))).
The goal is reached, represented in the following fact:
end(SanityA(false,((x1,sA_4,nA_4,exp_ideal(g,x_1)),(x1_1,x2,weak)))).


A more detailed output of the traces is available with
  set traceDisplay = long.

new sk: t_sk creating sk_2 at {2} in copy a

out(c, ~M) with ~M = pk(sk_2) at {3} in copy a

insert Keys(sk_2) at {4} in copy a

new sk: t_sk creating sk_3 at {2} in copy a_1

out(c, ~M_1) with ~M_1 = pk(sk_3) at {3} in copy a_1

insert Keys(sk_3) at {4} in copy a_1

get Keys(sk_2) at {87} in copy a_2

get Keys(sk_3) at {86} in copy a_2

new x: t_exponent creating x_1 at {9} in copy a_2

new nA: bitstring creating nA_4 at {10} in copy a_2

new sA: bitstring creating sA_4 at {11} in copy a_2

out(c, (~M_2,~M_3,~M_4)) with ~M_2 = sA_4, ~M_3 = nA_4, ~M_4 = exp_ideal(g,x_1) at {13} in copy a_2

in(c, (SA_INIT,a_3)) at {14} in copy a_2

in(c, (a_4,a_5,weak)) at {20} in copy a_2

event initA(pk(sk_2),pk(sk_3),(nA_4,a_5),((a_3,sA_4,nA_4,exp_ideal(g,x_1)),a_5),H_(MAC(pk(sk_2),KDF(weak,(nA_4,a_5),3)),H_(a_5,H_(exp_ideal(g,x_1),H_(nA_4,H_(sA_4,H_(a_3,NIL)))))),H(MAC(pk(sk_2),KDF(weak,(nA_4,a_5),3)),H(a_5,H(exp_ideal(g,x_1),H(nA_4,H(sA_4,H(a_3,NIL))))))) at {32} in copy a_2

event initA2(pk(sk_2),sA_4) at {33} in copy a_2

out(c, ~M_5) with ~M_5 = senc((pk(sk_2),sign(H(MAC(pk(sk_2),KDF(weak,(nA_4,a_5),3)),H(a_5,H(exp_ideal(g,x_1),H(nA_4,H(sA_4,H(a_3,NIL)))))),sk_2)),KDF(weak,(nA_4,a_5),1)) at {34} in copy a_2

get Keys(sk_3) at {91} in copy a_6

event Dishonest(pk(sk_3)) at {89} in copy a_6

out(c, ~M_6) with ~M_6 = sk_3 at {90} in copy a_6

in(c, senc((~M_1,sign(MDH((a_4,a_5,weak,~M_3,MAC(~M_1,KDF(weak,(~M_3,a_5),4)))),~M_6)),KDF(weak,(~M_3,a_5),2))) with senc((~M_1,sign(MDH((a_4,a_5,weak,~M_3,MAC(~M_1,KDF(weak,(~M_3,a_5),4)))),~M_6)),KDF(weak,(~M_3,a_5),2)) = senc((pk(sk_3),sign(H(MAC(pk(sk_3),KDF(weak,(nA_4,a_5),4)),H(nA_4,H(weak,H(a_5,H(a_4,NIL))))),sk_3)),KDF(weak,(nA_4,a_5),2)) at {35} in copy a_2

event SanityA(false,((a_3,sA_4,nA_4,exp_ideal(g,x_1)),(a_4,a_5,weak))) at {39} in copy a_2 (goal)

The event SanityA(false,((a_3,sA_4,nA_4,exp_ideal(g,x_1)),(a_4,a_5,weak))) is executed at {39} in copy a_2.
A trace has been found.
RESULT not event(SanityA(false,x_1)) is false.
Starting query not event(SanityB(true,x_1))
goal reachable: @sid ≠ @sid_1 && begin(Dishonest(pk(sk_2))) && attacker(mC_2) && attacker(x1) && attacker(x2) -> end(SanityB(true,((x1,x2,weak),(sB_2,nB_2,exp_ideal(g,y_1)))))
Abbreviations:
sk_3 = sk[!1 = @sid]
sk_2 = sk[!1 = @sid_1]
sB_2 = sB_1[mC_1 = mC_2,withCookie = false,m1'_1 = (x1,x2,weak),skB = sk_3,skA = sk_2,!1 = @sid_2]
nB_2 = nB_1[mC_1 = mC_2,withCookie = false,m1'_1 = (x1,x2,weak),skB = sk_3,skA = sk_2,!1 = @sid_2]
y_1 = y[mC_1 = mC_2,withCookie = false,m1'_1 = (x1,x2,weak),skB = sk_3,skA = sk_2,!1 = @sid_2]

Derivation:
Abbreviations:
sk_2 = sk[!1 = @sid]
sk_3 = sk[!1 = @sid_1]
sB_2 = sB_1[mC_1 = mC_2,withCookie = false,m1'_1 = (x1,x2,weak),skB = sk_2,skA = sk_3,!1 = @sid_2]
nB_2 = nB_1[mC_1 = mC_2,withCookie = false,m1'_1 = (x1,x2,weak),skB = sk_2,skA = sk_3,!1 = @sid_2]
y_1 = y[mC_1 = mC_2,withCookie = false,m1'_1 = (x1,x2,weak),skB = sk_2,skA = sk_3,!1 = @sid_2]

1. The entry Keys(sk_3) may be inserted in a table at insert {4}.
table(Keys(sk_3)).

2. The entry Keys(sk_2) may be inserted in a table at insert {4}.
table(Keys(sk_2)).

3. Using the function weak the attacker may obtain weak.
attacker(weak).

4. We assume as hypothesis that
attacker(x2).

5. We assume as hypothesis that
attacker(x1).

6. By 5, the attacker may know x1.
By 4, the attacker may know x2.
By 3, the attacker may know weak.
Using the function 3-tuple the attacker may obtain (x1,x2,weak).
attacker((x1,x2,weak)).

7. Using the function false the attacker may obtain false.
attacker(false).

8. We assume as hypothesis that
attacker(mC_2).

9. Using the function 0 the attacker may obtain 0.
attacker(0).

10. By 9, the attacker may know 0.
Using the function + the attacker may obtain 1.
attacker(1).

11. The entry Keys(sk_3) that may be in a table by 1 may be read at get {87}.
The entry Keys(sk_2) that may be in a table by 2 may be read at get {86}.
The message (x1,x2,weak) that the attacker may have by 6 may be received at input {45}.
The message false that the attacker may have by 7 may be received at input {48}.
The message mC_2 that the attacker may have by 8 may be received at input {49}.
We have false ≠ true && sk_2 ≠ sk_3.
So the message (sB_2,nB_2,exp_ideal(g,y_1)) may be sent to the attacker at output {77}.
attacker((sB_2,nB_2,exp_ideal(g,y_1))).

12. By 11, the attacker may know (sB_2,nB_2,exp_ideal(g,y_1)).
Using the function 2-proj-3-tuple the attacker may obtain nB_2.
attacker(nB_2).

13. By 4, the attacker may know x2.
By 12, the attacker may know nB_2.
Using the function 2-tuple the attacker may obtain (x2,nB_2).
attacker((x2,nB_2)).

14. By 3, the attacker may know weak.
By 13, the attacker may know (x2,nB_2).
By 10, the attacker may know 1.
Using the function KDF the attacker may obtain KDF(weak,(x2,nB_2),1).
attacker(KDF(weak,(x2,nB_2),1)).

15. The entry Keys(sk_3) that may be in a table by 1 may be read at get {91}.
The event Dishonest(pk(sk_3)) may be executed at {89}.
So the message sk_3 may be sent to the attacker at output {90}.
attacker(sk_3).

16. By 10, the attacker may know 1.
Using the function + the attacker may obtain 2.
attacker(2).

17. By 16, the attacker may know 2.
Using the function + the attacker may obtain 3.
attacker(3).

18. By 3, the attacker may know weak.
By 13, the attacker may know (x2,nB_2).
By 17, the attacker may know 3.
Using the function KDF the attacker may obtain KDF(weak,(x2,nB_2),3).
attacker(KDF(weak,(x2,nB_2),3)).

19. The message pk(sk_3) may be sent to the attacker at output {3}.
attacker(pk(sk_3)).

20. By 19, the attacker may know pk(sk_3).
By 18, the attacker may know KDF(weak,(x2,nB_2),3).
Using the function MAC the attacker may obtain MAC(pk(sk_3),KDF(weak,(x2,nB_2),3)).
attacker(MAC(pk(sk_3),KDF(weak,(x2,nB_2),3))).

21. By 5, the attacker may know x1.
By 4, the attacker may know x2.
By 3, the attacker may know weak.
By 12, the attacker may know nB_2.
By 20, the attacker may know MAC(pk(sk_3),KDF(weak,(x2,nB_2),3)).
Using the function 5-tuple the attacker may obtain (x1,x2,weak,nB_2,MAC(pk(sk_3),KDF(weak,(x2,nB_2),3))).
attacker((x1,x2,weak,nB_2,MAC(pk(sk_3),KDF(weak,(x2,nB_2),3)))).

22. By 21, the attacker may know (x1,x2,weak,nB_2,MAC(pk(sk_3),KDF(weak,(x2,nB_2),3))).
Using the function MDH the attacker may obtain H(MAC(pk(sk_3),KDF(weak,(x2,nB_2),3)),H(nB_2,H(weak,H(x2,H(x1,NIL))))).
attacker(H(MAC(pk(sk_3),KDF(weak,(x2,nB_2),3)),H(nB_2,H(weak,H(x2,H(x1,NIL)))))).

23. By 22, the attacker may know H(MAC(pk(sk_3),KDF(weak,(x2,nB_2),3)),H(nB_2,H(weak,H(x2,H(x1,NIL))))).
By 15, the attacker may know sk_3.
Using the function sign the attacker may obtain sign(H(MAC(pk(sk_3),KDF(weak,(x2,nB_2),3)),H(nB_2,H(weak,H(x2,H(x1,NIL))))),sk_3).
attacker(sign(H(MAC(pk(sk_3),KDF(weak,(x2,nB_2),3)),H(nB_2,H(weak,H(x2,H(x1,NIL))))),sk_3)).

24. By 19, the attacker may know pk(sk_3).
By 23, the attacker may know sign(H(MAC(pk(sk_3),KDF(weak,(x2,nB_2),3)),H(nB_2,H(weak,H(x2,H(x1,NIL))))),sk_3).
Using the function 2-tuple the attacker may obtain (pk(sk_3),sign(H(MAC(pk(sk_3),KDF(weak,(x2,nB_2),3)),H(nB_2,H(weak,H(x2,H(x1,NIL))))),sk_3)).
attacker((pk(sk_3),sign(H(MAC(pk(sk_3),KDF(weak,(x2,nB_2),3)),H(nB_2,H(weak,H(x2,H(x1,NIL))))),sk_3))).

25. By 24, the attacker may know (pk(sk_3),sign(H(MAC(pk(sk_3),KDF(weak,(x2,nB_2),3)),H(nB_2,H(weak,H(x2,H(x1,NIL))))),sk_3)).
By 14, the attacker may know KDF(weak,(x2,nB_2),1).
Using the function senc the attacker may obtain senc((pk(sk_3),sign(H(MAC(pk(sk_3),KDF(weak,(x2,nB_2),3)),H(nB_2,H(weak,H(x2,H(x1,NIL))))),sk_3)),KDF(weak,(x2,nB_2),1)).
attacker(senc((pk(sk_3),sign(H(MAC(pk(sk_3),KDF(weak,(x2,nB_2),3)),H(nB_2,H(weak,H(x2,H(x1,NIL))))),sk_3)),KDF(weak,(x2,nB_2),1))).

26. The entry Keys(sk_3) that may be in a table by 1 may be read at get {87}.
The entry Keys(sk_2) that may be in a table by 2 may be read at get {86}.
The message (x1,x2,weak) that the attacker may have by 6 may be received at input {45}.
The message false that the attacker may have by 7 may be received at input {48}.
The message mC_2 that the attacker may have by 8 may be received at input {49}.
The message senc((pk(sk_3),sign(H(MAC(pk(sk_3),KDF(weak,(x2,nB_2),3)),H(nB_2,H(weak,H(x2,H(x1,NIL))))),sk_3)),KDF(weak,(x2,nB_2),1)) that the attacker may have by 25 may be received at input {78}.
We have sk_2 ≠ sk_3.
So event SanityB(true,((x1,x2,weak),(sB_2,nB_2,exp_ideal(g,y_1)))) may be executed at {85}.
end(SanityB(true,((x1,x2,weak),(sB_2,nB_2,exp_ideal(g,y_1))))).

27. By 26, end(SanityB(true,((x1,x2,weak),(sB_2,nB_2,exp_ideal(g,y_1))))).
The goal is reached, represented in the following fact:
end(SanityB(true,((x1,x2,weak),(sB_2,nB_2,exp_ideal(g,y_1))))).


A more detailed output of the traces is available with
  set traceDisplay = long.

new sk: t_sk creating sk_2 at {2} in copy a

out(c, ~M) with ~M = pk(sk_2) at {3} in copy a

insert Keys(sk_2) at {4} in copy a

new sk: t_sk creating sk_3 at {2} in copy a_1

out(c, ~M_1) with ~M_1 = pk(sk_3) at {3} in copy a_1

insert Keys(sk_3) at {4} in copy a_1

get Keys(sk_2) at {87} in copy a_2

get Keys(sk_3) at {86} in copy a_2

new x: t_exponent creating x_1 at {9} in copy a_2

new nA: bitstring creating nA_4 at {10} in copy a_2

new sA: bitstring creating sA_4 at {11} in copy a_2

out(c, (~M_2,~M_3,~M_4)) with ~M_2 = sA_4, ~M_3 = nA_4, ~M_4 = exp_ideal(g,x_1) at {13} in copy a_2

in(c, (a_3,a_4,weak)) at {45} in copy a_2

new ck_1: bitstring creating ck_2 at {46} in copy a_2

out(c, ~M_5) with ~M_5 = ck_2 at {47} in copy a_2

in(c, false) at {48} in copy a_2

in(c, a_5) at {49} in copy a_2

new y: t_exponent creating y_1 at {64} in copy a_2

new nB_1: bitstring creating nB_2 at {65} in copy a_2

new sB_1: bitstring creating sB_2 at {66} in copy a_2

event initB(pk(sk_3),pk(sk_2),(a_4,nB_2),((a_3,a_4,weak),nB_2),H(MAC(pk(sk_2),KDF(weak,(a_4,nB_2),3)),H(nB_2,H(weak,H(a_4,H(a_3,NIL)))))) at {76} in copy a_2

out(c, (~M_6,~M_7,~M_8)) with ~M_6 = sB_2, ~M_7 = nB_2, ~M_8 = exp_ideal(g,y_1) at {77} in copy a_2

get Keys(sk_2) at {91} in copy a_6

event Dishonest(pk(sk_2)) at {89} in copy a_6

out(c, ~M_9) with ~M_9 = sk_2 at {90} in copy a_6

in(c, senc((~M,sign(MDH((a_3,a_4,weak,~M_7,MAC(~M,KDF(weak,(a_4,~M_7),3)))),~M_9)),KDF(weak,(a_4,~M_7),1))) with senc((~M,sign(MDH((a_3,a_4,weak,~M_7,MAC(~M,KDF(weak,(a_4,~M_7),3)))),~M_9)),KDF(weak,(a_4,~M_7),1)) = senc((pk(sk_2),sign(H(MAC(pk(sk_2),KDF(weak,(a_4,nB_2),3)),H(nB_2,H(weak,H(a_4,H(a_3,NIL))))),sk_2)),KDF(weak,(a_4,nB_2),1)) at {78} in copy a_2

event acceptB(pk(sk_3),pk(sk_2),(a_4,nB_2),((a_3,a_4,weak),nB_2),H_(MAC(pk(sk_2),KDF(weak,(a_4,nB_2),3)),H_(nB_2,H_(weak,H_(a_4,H_(a_3,NIL))))),H(MAC(pk(sk_2),KDF(weak,(a_4,nB_2),3)),H(nB_2,H(weak,H(a_4,H(a_3,NIL)))))) at {82} in copy a_2

event acceptB2(pk(sk_3),pk(sk_2),a_3) at {83} in copy a_2

event sessionKeyB(pk(sk_3),pk(sk_2),KDF(weak,(a_4,nB_2),1)) at {84} in copy a_2

event SanityB(true,((a_3,a_4,weak),(sB_2,nB_2,exp_ideal(g,y_1)))) at {85} in copy a_2 (goal)

The event SanityB(true,((a_3,a_4,weak),(sB_2,nB_2,exp_ideal(g,y_1)))) is executed at {85} in copy a_2.
A trace has been found.
RESULT not event(SanityB(true,x_1)) is false.
Starting query not event(SanityB(false,x_1))
goal reachable: @sid ≠ @sid_1 && begin(Dishonest(pk(sk_2))) && attacker(x2) && attacker(x3) && attacker(m1'_2) -> end(SanityB(false,((ck_2,x2,x3,weak),(sB_2,nB_2,exp_ideal(g,y_1)))))
Abbreviations:
sk_3 = sk[!1 = @sid]
sk_2 = sk[!1 = @sid_1]
ck_2 = ck_1[m1'_1 = m1'_2,skB = sk_3,skA = sk_2,!1 = @sid_2]
sB_2 = sB_1[mC_1 = (ck_2,x2,x3,weak),withCookie = true,m1'_1 = m1'_2,skB = sk_3,skA = sk_2,!1 = @sid_2]
nB_2 = nB_1[mC_1 = (ck_2,x2,x3,weak),withCookie = true,m1'_1 = m1'_2,skB = sk_3,skA = sk_2,!1 = @sid_2]
y_1 = y[mC_1 = (ck_2,x2,x3,weak),withCookie = true,m1'_1 = m1'_2,skB = sk_3,skA = sk_2,!1 = @sid_2]

Derivation:
Abbreviations:
sk_2 = sk[!1 = @sid]
sk_3 = sk[!1 = @sid_1]
ck_2 = ck_1[m1'_1 = m1'_2,skB = sk_2,skA = sk_3,!1 = @sid_2]
sB_2 = sB_1[mC_1 = (ck_2,x2,x3,weak),withCookie = true,m1'_1 = m1'_2,skB = sk_2,skA = sk_3,!1 = @sid_2]
nB_2 = nB_1[mC_1 = (ck_2,x2,x3,weak),withCookie = true,m1'_1 = m1'_2,skB = sk_2,skA = sk_3,!1 = @sid_2]
y_1 = y[mC_1 = (ck_2,x2,x3,weak),withCookie = true,m1'_1 = m1'_2,skB = sk_2,skA = sk_3,!1 = @sid_2]

1. The entry Keys(sk_3) may be inserted in a table at insert {4}.
table(Keys(sk_3)).

2. The entry Keys(sk_2) may be inserted in a table at insert {4}.
table(Keys(sk_2)).

3. We assume as hypothesis that
attacker(m1'_2).

4. Using the function true the attacker may obtain true.
attacker(true).

5. Using the function weak the attacker may obtain weak.
attacker(weak).

6. We assume as hypothesis that
attacker(x3).

7. We assume as hypothesis that
attacker(x2).

8. The entry Keys(sk_3) that may be in a table by 1 may be read at get {87}.
The entry Keys(sk_2) that may be in a table by 2 may be read at get {86}.
The message m1'_2 that the attacker may have by 3 may be received at input {45}.
We have sk_2 ≠ sk_3.
So the message ck_2 may be sent to the attacker at output {47}.
attacker(ck_2).

9. By 8, the attacker may know ck_2.
By 7, the attacker may know x2.
By 6, the attacker may know x3.
By 5, the attacker may know weak.
Using the function 4-tuple the attacker may obtain (ck_2,x2,x3,weak).
attacker((ck_2,x2,x3,weak)).

10. Using the function 0 the attacker may obtain 0.
attacker(0).

11. By 10, the attacker may know 0.
Using the function + the attacker may obtain 1.
attacker(1).

12. The entry Keys(sk_3) that may be in a table by 1 may be read at get {87}.
The entry Keys(sk_2) that may be in a table by 2 may be read at get {86}.
The message m1'_2 that the attacker may have by 3 may be received at input {45}.
The message true that the attacker may have by 4 may be received at input {48}.
The message (ck_2,x2,x3,weak) that the attacker may have by 9 may be received at input {49}.
We have sk_2 ≠ sk_3.
So the message (sB_2,nB_2,exp_ideal(g,y_1)) may be sent to the attacker at output {77}.
attacker((sB_2,nB_2,exp_ideal(g,y_1))).

13. By 12, the attacker may know (sB_2,nB_2,exp_ideal(g,y_1)).
Using the function 2-proj-3-tuple the attacker may obtain nB_2.
attacker(nB_2).

14. By 6, the attacker may know x3.
By 13, the attacker may know nB_2.
Using the function 2-tuple the attacker may obtain (x3,nB_2).
attacker((x3,nB_2)).

15. By 5, the attacker may know weak.
By 14, the attacker may know (x3,nB_2).
By 11, the attacker may know 1.
Using the function KDF the attacker may obtain KDF(weak,(x3,nB_2),1).
attacker(KDF(weak,(x3,nB_2),1)).

16. The entry Keys(sk_3) that may be in a table by 1 may be read at get {91}.
The event Dishonest(pk(sk_3)) may be executed at {89}.
So the message sk_3 may be sent to the attacker at output {90}.
attacker(sk_3).

17. By 11, the attacker may know 1.
Using the function + the attacker may obtain 2.
attacker(2).

18. By 17, the attacker may know 2.
Using the function + the attacker may obtain 3.
attacker(3).

19. By 5, the attacker may know weak.
By 14, the attacker may know (x3,nB_2).
By 18, the attacker may know 3.
Using the function KDF the attacker may obtain KDF(weak,(x3,nB_2),3).
attacker(KDF(weak,(x3,nB_2),3)).

20. The message pk(sk_3) may be sent to the attacker at output {3}.
attacker(pk(sk_3)).

21. By 20, the attacker may know pk(sk_3).
By 19, the attacker may know KDF(weak,(x3,nB_2),3).
Using the function MAC the attacker may obtain MAC(pk(sk_3),KDF(weak,(x3,nB_2),3)).
attacker(MAC(pk(sk_3),KDF(weak,(x3,nB_2),3))).

22. By 8, the attacker may know ck_2.
By 7, the attacker may know x2.
By 6, the attacker may know x3.
By 5, the attacker may know weak.
By 13, the attacker may know nB_2.
By 21, the attacker may know MAC(pk(sk_3),KDF(weak,(x3,nB_2),3)).
Using the function 6-tuple the attacker may obtain (ck_2,x2,x3,weak,nB_2,MAC(pk(sk_3),KDF(weak,(x3,nB_2),3))).
attacker((ck_2,x2,x3,weak,nB_2,MAC(pk(sk_3),KDF(weak,(x3,nB_2),3)))).

23. By 22, the attacker may know (ck_2,x2,x3,weak,nB_2,MAC(pk(sk_3),KDF(weak,(x3,nB_2),3))).
Using the function MDH the attacker may obtain H(MAC(pk(sk_3),KDF(weak,(x3,nB_2),3)),H(nB_2,H(weak,H(x3,H(x2,H(ck_2,NIL)))))).
attacker(H(MAC(pk(sk_3),KDF(weak,(x3,nB_2),3)),H(nB_2,H(weak,H(x3,H(x2,H(ck_2,NIL))))))).

24. By 23, the attacker may know H(MAC(pk(sk_3),KDF(weak,(x3,nB_2),3)),H(nB_2,H(weak,H(x3,H(x2,H(ck_2,NIL)))))).
By 16, the attacker may know sk_3.
Using the function sign the attacker may obtain sign(H(MAC(pk(sk_3),KDF(weak,(x3,nB_2),3)),H(nB_2,H(weak,H(x3,H(x2,H(ck_2,NIL)))))),sk_3).
attacker(sign(H(MAC(pk(sk_3),KDF(weak,(x3,nB_2),3)),H(nB_2,H(weak,H(x3,H(x2,H(ck_2,NIL)))))),sk_3)).

25. By 20, the attacker may know pk(sk_3).
By 24, the attacker may know sign(H(MAC(pk(sk_3),KDF(weak,(x3,nB_2),3)),H(nB_2,H(weak,H(x3,H(x2,H(ck_2,NIL)))))),sk_3).
Using the function 2-tuple the attacker may obtain (pk(sk_3),sign(H(MAC(pk(sk_3),KDF(weak,(x3,nB_2),3)),H(nB_2,H(weak,H(x3,H(x2,H(ck_2,NIL)))))),sk_3)).
attacker((pk(sk_3),sign(H(MAC(pk(sk_3),KDF(weak,(x3,nB_2),3)),H(nB_2,H(weak,H(x3,H(x2,H(ck_2,NIL)))))),sk_3))).

26. By 25, the attacker may know (pk(sk_3),sign(H(MAC(pk(sk_3),KDF(weak,(x3,nB_2),3)),H(nB_2,H(weak,H(x3,H(x2,H(ck_2,NIL)))))),sk_3)).
By 15, the attacker may know KDF(weak,(x3,nB_2),1).
Using the function senc the attacker may obtain senc((pk(sk_3),sign(H(MAC(pk(sk_3),KDF(weak,(x3,nB_2),3)),H(nB_2,H(weak,H(x3,H(x2,H(ck_2,NIL)))))),sk_3)),KDF(weak,(x3,nB_2),1)).
attacker(senc((pk(sk_3),sign(H(MAC(pk(sk_3),KDF(weak,(x3,nB_2),3)),H(nB_2,H(weak,H(x3,H(x2,H(ck_2,NIL)))))),sk_3)),KDF(weak,(x3,nB_2),1))).

27. The entry Keys(sk_3) that may be in a table by 1 may be read at get {87}.
The entry Keys(sk_2) that may be in a table by 2 may be read at get {86}.
The message m1'_2 that the attacker may have by 3 may be received at input {45}.
The message true that the attacker may have by 4 may be received at input {48}.
The message (ck_2,x2,x3,weak) that the attacker may have by 9 may be received at input {49}.
The message senc((pk(sk_3),sign(H(MAC(pk(sk_3),KDF(weak,(x3,nB_2),3)),H(nB_2,H(weak,H(x3,H(x2,H(ck_2,NIL)))))),sk_3)),KDF(weak,(x3,nB_2),1)) that the attacker may have by 26 may be received at input {78}.
We have sk_2 ≠ sk_3.
So event SanityB(false,((ck_2,x2,x3,weak),(sB_2,nB_2,exp_ideal(g,y_1)))) may be executed at {85}.
end(SanityB(false,((ck_2,x2,x3,weak),(sB_2,nB_2,exp_ideal(g,y_1))))).

28. By 27, end(SanityB(false,((ck_2,x2,x3,weak),(sB_2,nB_2,exp_ideal(g,y_1))))).
The goal is reached, represented in the following fact:
end(SanityB(false,((ck_2,x2,x3,weak),(sB_2,nB_2,exp_ideal(g,y_1))))).


A more detailed output of the traces is available with
  set traceDisplay = long.

new sk: t_sk creating sk_2 at {2} in copy a

out(c, ~M) with ~M = pk(sk_2) at {3} in copy a

insert Keys(sk_2) at {4} in copy a

new sk: t_sk creating sk_3 at {2} in copy a_1

out(c, ~M_1) with ~M_1 = pk(sk_3) at {3} in copy a_1

insert Keys(sk_3) at {4} in copy a_1

get Keys(sk_2) at {87} in copy a_2

get Keys(sk_3) at {86} in copy a_2

new x: t_exponent creating x_1 at {9} in copy a_2

new nA: bitstring creating nA_4 at {10} in copy a_2

new sA: bitstring creating sA_4 at {11} in copy a_2

out(c, (~M_2,~M_3,~M_4)) with ~M_2 = sA_4, ~M_3 = nA_4, ~M_4 = exp_ideal(g,x_1) at {13} in copy a_2

in(c, a_3) at {45} in copy a_2

new ck_1: bitstring creating ck_2 at {46} in copy a_2

out(c, ~M_5) with ~M_5 = ck_2 at {47} in copy a_2

in(c, true) at {48} in copy a_2

in(c, (~M_5,a_4,a_5,weak)) with ~M_5 = ck_2 at {49} in copy a_2

new y: t_exponent creating y_1 at {64} in copy a_2

new nB_1: bitstring creating nB_2 at {65} in copy a_2

new sB_1: bitstring creating sB_2 at {66} in copy a_2

event initB(pk(sk_3),pk(sk_2),(a_5,nB_2),((ck_2,a_4,a_5,weak),nB_2),H(MAC(pk(sk_2),KDF(weak,(a_5,nB_2),3)),H(nB_2,H(weak,H(a_5,H(a_4,H(ck_2,NIL))))))) at {76} in copy a_2

out(c, (~M_6,~M_7,~M_8)) with ~M_6 = sB_2, ~M_7 = nB_2, ~M_8 = exp_ideal(g,y_1) at {77} in copy a_2

get Keys(sk_2) at {91} in copy a_6

event Dishonest(pk(sk_2)) at {89} in copy a_6

out(c, ~M_9) with ~M_9 = sk_2 at {90} in copy a_6

in(c, senc((~M,sign(MDH((~M_5,a_4,a_5,weak,~M_7,MAC(~M,KDF(weak,(a_5,~M_7),3)))),~M_9)),KDF(weak,(a_5,~M_7),1))) with senc((~M,sign(MDH((~M_5,a_4,a_5,weak,~M_7,MAC(~M,KDF(weak,(a_5,~M_7),3)))),~M_9)),KDF(weak,(a_5,~M_7),1)) = senc((pk(sk_2),sign(H(MAC(pk(sk_2),KDF(weak,(a_5,nB_2),3)),H(nB_2,H(weak,H(a_5,H(a_4,H(ck_2,NIL)))))),sk_2)),KDF(weak,(a_5,nB_2),1)) at {78} in copy a_2

event acceptB(pk(sk_3),pk(sk_2),(a_5,nB_2),((ck_2,a_4,a_5,weak),nB_2),H_(MAC(pk(sk_2),KDF(weak,(a_5,nB_2),3)),H_(nB_2,H_(weak,H_(a_5,H_(a_4,H_(ck_2,NIL)))))),H(MAC(pk(sk_2),KDF(weak,(a_5,nB_2),3)),H(nB_2,H(weak,H(a_5,H(a_4,H(ck_2,NIL))))))) at {82} in copy a_2

event acceptB2(pk(sk_3),pk(sk_2),a_4) at {83} in copy a_2

event sessionKeyB(pk(sk_3),pk(sk_2),KDF(weak,(a_5,nB_2),1)) at {84} in copy a_2

event SanityB(false,((ck_2,a_4,a_5,weak),(sB_2,nB_2,exp_ideal(g,y_1)))) at {85} in copy a_2 (goal)

The event SanityB(false,((ck_2,a_4,a_5,weak),(sB_2,nB_2,exp_ideal(g,y_1)))) is executed at {85} in copy a_2.
A trace has been found.
RESULT not event(SanityB(false,x_1)) is false.
Starting query not attacker(secr)
RESULT not attacker(secr) is true.

--------------------------------------------------------------
Verification summary:

Query event(acceptB2(B_1,A_1,sA_4)) ==> event(initA2(A_1,sA_4)) || event(Dishonest(B_1)) || event(Dishonest(A_1)) is true.

Query event(acceptB(B_1,A_1,x_1,y_1,t,h)) ==> event(initA(A_1,B',x',y',t,h')) || event(Dishonest(B_1)) || event(Dishonest(A_1)) is true.

Query event(acceptB(B_1,A_1,x_1,y_1,t,h)) ==> event(initA(A_1,B',x',y',t',h)) || event(Dishonest(B_1)) || event(Dishonest(A_1)) is true.

Query not event(SanityA(true,x_1)) is false.

Query not event(SanityA(false,x_1)) is false.

Query not event(SanityB(true,x_1)) is false.

Query not event(SanityB(false,x_1)) is false.

Query not attacker(secr) is true.

--------------------------------------------------------------

END DATE: 13.10.25 -- 02:13:11
